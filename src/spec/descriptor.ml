(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: google/protobuf/descriptor.proto
  Syntax: proto2
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
module rec Google : sig
  module rec Protobuf : sig
    module rec FileDescriptorSet : sig
      val name': unit -> string
      type t = (FileDescriptorProto.t list)
      val make: ?file:FileDescriptorProto.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and FileDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; package: string option; dependency: string list; message_type: DescriptorProto.t list; enum_type: EnumDescriptorProto.t list; service: ServiceDescriptorProto.t list; extension: FieldDescriptorProto.t list; options: FileOptions.t option; source_code_info: SourceCodeInfo.t option; public_dependency: int list; weak_dependency: int list; syntax: string option }
      val make: ?name:string -> ?package:string -> ?dependency:string list -> ?message_type:DescriptorProto.t list -> ?enum_type:EnumDescriptorProto.t list -> ?service:ServiceDescriptorProto.t list -> ?extension:FieldDescriptorProto.t list -> ?options:FileOptions.t -> ?source_code_info:SourceCodeInfo.t -> ?public_dependency:int list -> ?weak_dependency:int list -> ?syntax:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and DescriptorProto : sig
      module rec ExtensionRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option; options: ExtensionRangeOptions.t option }
        val make: ?start:int -> ?end':int -> ?options:ExtensionRangeOptions.t -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      and ReservedRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option }
        val make: ?start:int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { name: string option; field: FieldDescriptorProto.t list; nested_type: DescriptorProto.t list; enum_type: EnumDescriptorProto.t list; extension_range: ExtensionRange.t list; extension: FieldDescriptorProto.t list; options: MessageOptions.t option; oneof_decl: OneofDescriptorProto.t list; reserved_range: ReservedRange.t list; reserved_name: string list }
      val make: ?name:string -> ?field:FieldDescriptorProto.t list -> ?nested_type:DescriptorProto.t list -> ?enum_type:EnumDescriptorProto.t list -> ?extension_range:ExtensionRange.t list -> ?extension:FieldDescriptorProto.t list -> ?options:MessageOptions.t -> ?oneof_decl:OneofDescriptorProto.t list -> ?reserved_range:ReservedRange.t list -> ?reserved_name:string list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and ExtensionRangeOptions : sig
      val name': unit -> string
      type t = { uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and FieldDescriptorProto : sig
      module rec Type : sig
        type t = TYPE_DOUBLE | TYPE_FLOAT | TYPE_INT64 | TYPE_UINT64 | TYPE_INT32 | TYPE_FIXED64 | TYPE_FIXED32 | TYPE_BOOL | TYPE_STRING | TYPE_GROUP | TYPE_MESSAGE | TYPE_BYTES | TYPE_UINT32 | TYPE_ENUM | TYPE_SFIXED32 | TYPE_SFIXED64 | TYPE_SINT32 | TYPE_SINT64
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      and Label : sig
        type t = LABEL_OPTIONAL | LABEL_REQUIRED | LABEL_REPEATED
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { name: string option; extendee: string option; number: int option; label: Label.t option; type': Type.t option; type_name: string option; default_value: string option; options: FieldOptions.t option; oneof_index: int option; json_name: string option; proto3_optional: bool option }
      val make: ?name:string -> ?extendee:string -> ?number:int -> ?label:Label.t -> ?type':Type.t -> ?type_name:string -> ?default_value:string -> ?options:FieldOptions.t -> ?oneof_index:int -> ?json_name:string -> ?proto3_optional:bool -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and OneofDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; options: OneofOptions.t option }
      val make: ?name:string -> ?options:OneofOptions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and EnumDescriptorProto : sig
      module rec EnumReservedRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option }
        val make: ?start:int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { name: string option; value: EnumValueDescriptorProto.t list; options: EnumOptions.t option; reserved_range: EnumReservedRange.t list; reserved_name: string list }
      val make: ?name:string -> ?value:EnumValueDescriptorProto.t list -> ?options:EnumOptions.t -> ?reserved_range:EnumReservedRange.t list -> ?reserved_name:string list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and EnumValueDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; number: int option; options: EnumValueOptions.t option }
      val make: ?name:string -> ?number:int -> ?options:EnumValueOptions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and ServiceDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; method': MethodDescriptorProto.t list; options: ServiceOptions.t option }
      val make: ?name:string -> ?method':MethodDescriptorProto.t list -> ?options:ServiceOptions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and MethodDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; input_type: string option; output_type: string option; options: MethodOptions.t option; client_streaming: bool; server_streaming: bool }
      val make: ?name:string -> ?input_type:string -> ?output_type:string -> ?options:MethodOptions.t -> ?client_streaming:bool -> ?server_streaming:bool -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and FileOptions : sig
      module rec OptimizeMode : sig
        type t = SPEED | CODE_SIZE | LITE_RUNTIME
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { java_package: string option; java_outer_classname: string option; optimize_for: OptimizeMode.t; java_multiple_files: bool; go_package: string option; cc_generic_services: bool; java_generic_services: bool; py_generic_services: bool; java_generate_equals_and_hash: bool option; deprecated: bool; java_string_check_utf8: bool; cc_enable_arenas: bool; objc_class_prefix: string option; csharp_namespace: string option; swift_prefix: string option; php_class_prefix: string option; php_namespace: string option; php_generic_services: bool; php_metadata_namespace: string option; ruby_package: string option; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?java_package:string -> ?java_outer_classname:string -> ?optimize_for:OptimizeMode.t -> ?java_multiple_files:bool -> ?go_package:string -> ?cc_generic_services:bool -> ?java_generic_services:bool -> ?py_generic_services:bool -> ?java_generate_equals_and_hash:bool -> ?deprecated:bool -> ?java_string_check_utf8:bool -> ?cc_enable_arenas:bool -> ?objc_class_prefix:string -> ?csharp_namespace:string -> ?swift_prefix:string -> ?php_class_prefix:string -> ?php_namespace:string -> ?php_generic_services:bool -> ?php_metadata_namespace:string -> ?ruby_package:string -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and MessageOptions : sig
      val name': unit -> string
      type t = { message_set_wire_format: bool; no_standard_descriptor_accessor: bool; deprecated: bool; map_entry: bool option; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?message_set_wire_format:bool -> ?no_standard_descriptor_accessor:bool -> ?deprecated:bool -> ?map_entry:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and FieldOptions : sig
      module rec CType : sig
        type t = STRING | CORD | STRING_PIECE
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      and JSType : sig
        type t = JS_NORMAL | JS_STRING | JS_NUMBER
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { ctype: CType.t; packed: bool option; deprecated: bool; lazy': bool; jstype: JSType.t; weak: bool; unverified_lazy: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?ctype:CType.t -> ?packed:bool -> ?deprecated:bool -> ?lazy':bool -> ?jstype:JSType.t -> ?weak:bool -> ?unverified_lazy:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and OneofOptions : sig
      val name': unit -> string
      type t = { uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and EnumOptions : sig
      val name': unit -> string
      type t = { allow_alias: bool option; deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?allow_alias:bool -> ?deprecated:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and EnumValueOptions : sig
      val name': unit -> string
      type t = { deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?deprecated:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and ServiceOptions : sig
      val name': unit -> string
      type t = { deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?deprecated:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and MethodOptions : sig
      module rec IdempotencyLevel : sig
        type t = IDEMPOTENCY_UNKNOWN | NO_SIDE_EFFECTS | IDEMPOTENT
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { deprecated: bool; idempotency_level: IdempotencyLevel.t; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?deprecated:bool -> ?idempotency_level:IdempotencyLevel.t -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and UninterpretedOption : sig
      module rec NamePart : sig
        val name': unit -> string
        type t = { name_part: string; is_extension: bool }
        val make: name_part:string -> is_extension:bool -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { name: NamePart.t list; identifier_value: string option; positive_int_value: int option; negative_int_value: int option; double_value: float option; string_value: bytes option; aggregate_value: string option }
      val make: ?name:NamePart.t list -> ?identifier_value:string -> ?positive_int_value:int -> ?negative_int_value:int -> ?double_value:float -> ?string_value:bytes -> ?aggregate_value:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and SourceCodeInfo : sig
      module rec Location : sig
        val name': unit -> string
        type t = { path: int list; span: int list; leading_comments: string option; trailing_comments: string option; leading_detached_comments: string list }
        val make: ?path:int list -> ?span:int list -> ?leading_comments:string -> ?trailing_comments:string -> ?leading_detached_comments:string list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = (Location.t list)
      val make: ?location:Location.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and GeneratedCodeInfo : sig
      module rec Annotation : sig
        val name': unit -> string
        type t = { path: int list; source_file: string option; begin': int option; end': int option }
        val make: ?path:int list -> ?source_file:string -> ?begin':int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = (Annotation.t list)
      val make: ?annotation:Annotation.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
  end
end = struct
  module rec Protobuf : sig
    module rec FileDescriptorSet : sig
      val name': unit -> string
      type t = (FileDescriptorProto.t list)
      val make: ?file:FileDescriptorProto.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and FileDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; package: string option; dependency: string list; message_type: DescriptorProto.t list; enum_type: EnumDescriptorProto.t list; service: ServiceDescriptorProto.t list; extension: FieldDescriptorProto.t list; options: FileOptions.t option; source_code_info: SourceCodeInfo.t option; public_dependency: int list; weak_dependency: int list; syntax: string option }
      val make: ?name:string -> ?package:string -> ?dependency:string list -> ?message_type:DescriptorProto.t list -> ?enum_type:EnumDescriptorProto.t list -> ?service:ServiceDescriptorProto.t list -> ?extension:FieldDescriptorProto.t list -> ?options:FileOptions.t -> ?source_code_info:SourceCodeInfo.t -> ?public_dependency:int list -> ?weak_dependency:int list -> ?syntax:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and DescriptorProto : sig
      module rec ExtensionRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option; options: ExtensionRangeOptions.t option }
        val make: ?start:int -> ?end':int -> ?options:ExtensionRangeOptions.t -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      and ReservedRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option }
        val make: ?start:int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { name: string option; field: FieldDescriptorProto.t list; nested_type: DescriptorProto.t list; enum_type: EnumDescriptorProto.t list; extension_range: ExtensionRange.t list; extension: FieldDescriptorProto.t list; options: MessageOptions.t option; oneof_decl: OneofDescriptorProto.t list; reserved_range: ReservedRange.t list; reserved_name: string list }
      val make: ?name:string -> ?field:FieldDescriptorProto.t list -> ?nested_type:DescriptorProto.t list -> ?enum_type:EnumDescriptorProto.t list -> ?extension_range:ExtensionRange.t list -> ?extension:FieldDescriptorProto.t list -> ?options:MessageOptions.t -> ?oneof_decl:OneofDescriptorProto.t list -> ?reserved_range:ReservedRange.t list -> ?reserved_name:string list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and ExtensionRangeOptions : sig
      val name': unit -> string
      type t = { uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and FieldDescriptorProto : sig
      module rec Type : sig
        type t = TYPE_DOUBLE | TYPE_FLOAT | TYPE_INT64 | TYPE_UINT64 | TYPE_INT32 | TYPE_FIXED64 | TYPE_FIXED32 | TYPE_BOOL | TYPE_STRING | TYPE_GROUP | TYPE_MESSAGE | TYPE_BYTES | TYPE_UINT32 | TYPE_ENUM | TYPE_SFIXED32 | TYPE_SFIXED64 | TYPE_SINT32 | TYPE_SINT64
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      and Label : sig
        type t = LABEL_OPTIONAL | LABEL_REQUIRED | LABEL_REPEATED
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { name: string option; extendee: string option; number: int option; label: Label.t option; type': Type.t option; type_name: string option; default_value: string option; options: FieldOptions.t option; oneof_index: int option; json_name: string option; proto3_optional: bool option }
      val make: ?name:string -> ?extendee:string -> ?number:int -> ?label:Label.t -> ?type':Type.t -> ?type_name:string -> ?default_value:string -> ?options:FieldOptions.t -> ?oneof_index:int -> ?json_name:string -> ?proto3_optional:bool -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and OneofDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; options: OneofOptions.t option }
      val make: ?name:string -> ?options:OneofOptions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and EnumDescriptorProto : sig
      module rec EnumReservedRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option }
        val make: ?start:int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { name: string option; value: EnumValueDescriptorProto.t list; options: EnumOptions.t option; reserved_range: EnumReservedRange.t list; reserved_name: string list }
      val make: ?name:string -> ?value:EnumValueDescriptorProto.t list -> ?options:EnumOptions.t -> ?reserved_range:EnumReservedRange.t list -> ?reserved_name:string list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and EnumValueDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; number: int option; options: EnumValueOptions.t option }
      val make: ?name:string -> ?number:int -> ?options:EnumValueOptions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and ServiceDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; method': MethodDescriptorProto.t list; options: ServiceOptions.t option }
      val make: ?name:string -> ?method':MethodDescriptorProto.t list -> ?options:ServiceOptions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and MethodDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; input_type: string option; output_type: string option; options: MethodOptions.t option; client_streaming: bool; server_streaming: bool }
      val make: ?name:string -> ?input_type:string -> ?output_type:string -> ?options:MethodOptions.t -> ?client_streaming:bool -> ?server_streaming:bool -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and FileOptions : sig
      module rec OptimizeMode : sig
        type t = SPEED | CODE_SIZE | LITE_RUNTIME
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { java_package: string option; java_outer_classname: string option; optimize_for: OptimizeMode.t; java_multiple_files: bool; go_package: string option; cc_generic_services: bool; java_generic_services: bool; py_generic_services: bool; java_generate_equals_and_hash: bool option; deprecated: bool; java_string_check_utf8: bool; cc_enable_arenas: bool; objc_class_prefix: string option; csharp_namespace: string option; swift_prefix: string option; php_class_prefix: string option; php_namespace: string option; php_generic_services: bool; php_metadata_namespace: string option; ruby_package: string option; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?java_package:string -> ?java_outer_classname:string -> ?optimize_for:OptimizeMode.t -> ?java_multiple_files:bool -> ?go_package:string -> ?cc_generic_services:bool -> ?java_generic_services:bool -> ?py_generic_services:bool -> ?java_generate_equals_and_hash:bool -> ?deprecated:bool -> ?java_string_check_utf8:bool -> ?cc_enable_arenas:bool -> ?objc_class_prefix:string -> ?csharp_namespace:string -> ?swift_prefix:string -> ?php_class_prefix:string -> ?php_namespace:string -> ?php_generic_services:bool -> ?php_metadata_namespace:string -> ?ruby_package:string -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and MessageOptions : sig
      val name': unit -> string
      type t = { message_set_wire_format: bool; no_standard_descriptor_accessor: bool; deprecated: bool; map_entry: bool option; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?message_set_wire_format:bool -> ?no_standard_descriptor_accessor:bool -> ?deprecated:bool -> ?map_entry:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and FieldOptions : sig
      module rec CType : sig
        type t = STRING | CORD | STRING_PIECE
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      and JSType : sig
        type t = JS_NORMAL | JS_STRING | JS_NUMBER
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { ctype: CType.t; packed: bool option; deprecated: bool; lazy': bool; jstype: JSType.t; weak: bool; unverified_lazy: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?ctype:CType.t -> ?packed:bool -> ?deprecated:bool -> ?lazy':bool -> ?jstype:JSType.t -> ?weak:bool -> ?unverified_lazy:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and OneofOptions : sig
      val name': unit -> string
      type t = { uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and EnumOptions : sig
      val name': unit -> string
      type t = { allow_alias: bool option; deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?allow_alias:bool -> ?deprecated:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and EnumValueOptions : sig
      val name': unit -> string
      type t = { deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?deprecated:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and ServiceOptions : sig
      val name': unit -> string
      type t = { deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?deprecated:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and MethodOptions : sig
      module rec IdempotencyLevel : sig
        type t = IDEMPOTENCY_UNKNOWN | NO_SIDE_EFFECTS | IDEMPOTENT
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { deprecated: bool; idempotency_level: IdempotencyLevel.t; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?deprecated:bool -> ?idempotency_level:IdempotencyLevel.t -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and UninterpretedOption : sig
      module rec NamePart : sig
        val name': unit -> string
        type t = { name_part: string; is_extension: bool }
        val make: name_part:string -> is_extension:bool -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { name: NamePart.t list; identifier_value: string option; positive_int_value: int option; negative_int_value: int option; double_value: float option; string_value: bytes option; aggregate_value: string option }
      val make: ?name:NamePart.t list -> ?identifier_value:string -> ?positive_int_value:int -> ?negative_int_value:int -> ?double_value:float -> ?string_value:bytes -> ?aggregate_value:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and SourceCodeInfo : sig
      module rec Location : sig
        val name': unit -> string
        type t = { path: int list; span: int list; leading_comments: string option; trailing_comments: string option; leading_detached_comments: string list }
        val make: ?path:int list -> ?span:int list -> ?leading_comments:string -> ?trailing_comments:string -> ?leading_detached_comments:string list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = (Location.t list)
      val make: ?location:Location.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
    and GeneratedCodeInfo : sig
      module rec Annotation : sig
        val name': unit -> string
        type t = { path: int list; source_file: string option; begin': int option; end': int option }
        val make: ?path:int list -> ?source_file:string -> ?begin':int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = (Annotation.t list)
      val make: ?annotation:Annotation.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end
  end = struct
    module rec FileDescriptorSet : sig
      val name': unit -> string
      type t = (FileDescriptorProto.t list)
      val make: ?file:FileDescriptorProto.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.FileDescriptorSet"
      type t = (FileDescriptorProto.t list)
      let make ?(file = []) () = (file)
      let merge = (fun (t1_file) (t2_file) -> (Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "file", "file"), (message (module FileDescriptorProto)), not_packed) ) t1_file t2_file))
      let spec () = Runtime'.Spec.( repeated ((1, "file", "file"), (message (module FileDescriptorProto)), not_packed) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        serialize

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun file -> (file) in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        serialize
      let from_json_exn =
        let constructor = fun file -> (file) in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and FileDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; package: string option; dependency: string list; message_type: DescriptorProto.t list; enum_type: EnumDescriptorProto.t list; service: ServiceDescriptorProto.t list; extension: FieldDescriptorProto.t list; options: FileOptions.t option; source_code_info: SourceCodeInfo.t option; public_dependency: int list; weak_dependency: int list; syntax: string option }
      val make: ?name:string -> ?package:string -> ?dependency:string list -> ?message_type:DescriptorProto.t list -> ?enum_type:EnumDescriptorProto.t list -> ?service:ServiceDescriptorProto.t list -> ?extension:FieldDescriptorProto.t list -> ?options:FileOptions.t -> ?source_code_info:SourceCodeInfo.t -> ?public_dependency:int list -> ?weak_dependency:int list -> ?syntax:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.FileDescriptorProto"
      type t = { name: string option; package: string option; dependency: string list; message_type: DescriptorProto.t list; enum_type: EnumDescriptorProto.t list; service: ServiceDescriptorProto.t list; extension: FieldDescriptorProto.t list; options: FileOptions.t option; source_code_info: SourceCodeInfo.t option; public_dependency: int list; weak_dependency: int list; syntax: string option }
      let make ?name ?package ?(dependency = []) ?(message_type = []) ?(enum_type = []) ?(service = []) ?(extension = []) ?options ?source_code_info ?(public_dependency = []) ?(weak_dependency = []) ?syntax () = { name; package; dependency; message_type; enum_type; service; extension; options; source_code_info; public_dependency; weak_dependency; syntax }
      let merge = (fun t1 t2 -> {
        name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ) t1.name t2.name);
        package = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "package", "package"), string) ) t1.package t2.package);
        dependency = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "dependency", "dependency"), string, not_packed) ) t1.dependency t2.dependency);
        message_type = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((4, "message_type", "messageType"), (message (module DescriptorProto)), not_packed) ) t1.message_type t2.message_type);
        enum_type = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((5, "enum_type", "enumType"), (message (module EnumDescriptorProto)), not_packed) ) t1.enum_type t2.enum_type);
        service = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((6, "service", "service"), (message (module ServiceDescriptorProto)), not_packed) ) t1.service t2.service);
        extension = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((7, "extension", "extension"), (message (module FieldDescriptorProto)), not_packed) ) t1.extension t2.extension);
        options = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((8, "options", "options"), (message (module FileOptions))) ) t1.options t2.options);
        source_code_info = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((9, "source_code_info", "sourceCodeInfo"), (message (module SourceCodeInfo))) ) t1.source_code_info t2.source_code_info);
        public_dependency = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((10, "public_dependency", "publicDependency"), int32_int, not_packed) ) t1.public_dependency t2.public_dependency);
        weak_dependency = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((11, "weak_dependency", "weakDependency"), int32_int, not_packed) ) t1.weak_dependency t2.weak_dependency);
        syntax = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((12, "syntax", "syntax"), string) ) t1.syntax t2.syntax);
         })
      let spec () = Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ^:: basic_opt ((2, "package", "package"), string) ^:: repeated ((3, "dependency", "dependency"), string, not_packed) ^:: repeated ((4, "message_type", "messageType"), (message (module DescriptorProto)), not_packed) ^:: repeated ((5, "enum_type", "enumType"), (message (module EnumDescriptorProto)), not_packed) ^:: repeated ((6, "service", "service"), (message (module ServiceDescriptorProto)), not_packed) ^:: repeated ((7, "extension", "extension"), (message (module FieldDescriptorProto)), not_packed) ^:: basic_opt ((8, "options", "options"), (message (module FileOptions))) ^:: basic_opt ((9, "source_code_info", "sourceCodeInfo"), (message (module SourceCodeInfo))) ^:: repeated ((10, "public_dependency", "publicDependency"), int32_int, not_packed) ^:: repeated ((11, "weak_dependency", "weakDependency"), int32_int, not_packed) ^:: basic_opt ((12, "syntax", "syntax"), string) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { name; package; dependency; message_type; enum_type; service; extension; options; source_code_info; public_dependency; weak_dependency; syntax } -> serialize writer name package dependency message_type enum_type service extension options source_code_info public_dependency weak_dependency syntax

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun name package dependency message_type enum_type service extension options source_code_info public_dependency weak_dependency syntax -> { name; package; dependency; message_type; enum_type; service; extension; options; source_code_info; public_dependency; weak_dependency; syntax } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { name; package; dependency; message_type; enum_type; service; extension; options; source_code_info; public_dependency; weak_dependency; syntax } -> serialize name package dependency message_type enum_type service extension options source_code_info public_dependency weak_dependency syntax
      let from_json_exn =
        let constructor = fun name package dependency message_type enum_type service extension options source_code_info public_dependency weak_dependency syntax -> { name; package; dependency; message_type; enum_type; service; extension; options; source_code_info; public_dependency; weak_dependency; syntax } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and DescriptorProto : sig
      module rec ExtensionRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option; options: ExtensionRangeOptions.t option }
        val make: ?start:int -> ?end':int -> ?options:ExtensionRangeOptions.t -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      and ReservedRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option }
        val make: ?start:int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { name: string option; field: FieldDescriptorProto.t list; nested_type: DescriptorProto.t list; enum_type: EnumDescriptorProto.t list; extension_range: ExtensionRange.t list; extension: FieldDescriptorProto.t list; options: MessageOptions.t option; oneof_decl: OneofDescriptorProto.t list; reserved_range: ReservedRange.t list; reserved_name: string list }
      val make: ?name:string -> ?field:FieldDescriptorProto.t list -> ?nested_type:DescriptorProto.t list -> ?enum_type:EnumDescriptorProto.t list -> ?extension_range:ExtensionRange.t list -> ?extension:FieldDescriptorProto.t list -> ?options:MessageOptions.t -> ?oneof_decl:OneofDescriptorProto.t list -> ?reserved_range:ReservedRange.t list -> ?reserved_name:string list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      module rec ExtensionRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option; options: ExtensionRangeOptions.t option }
        val make: ?start:int -> ?end':int -> ?options:ExtensionRangeOptions.t -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end = struct
        let name' () = "descriptor.google.protobuf.DescriptorProto.ExtensionRange"
        type t = { start: int option; end': int option; options: ExtensionRangeOptions.t option }
        let make ?start ?end' ?options () = { start; end'; options }
        let merge = (fun t1 t2 -> {
          start = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "start", "start"), int32_int) ) t1.start t2.start);
          end' = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "end", "end"), int32_int) ) t1.end' t2.end');
          options = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "options", "options"), (message (module ExtensionRangeOptions))) ) t1.options t2.options);
           })
        let spec () = Runtime'.Spec.( basic_opt ((1, "start", "start"), int32_int) ^:: basic_opt ((2, "end", "end"), int32_int) ^:: basic_opt ((3, "options", "options"), (message (module ExtensionRangeOptions))) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.Serialize.serialize (spec ()) in
          fun writer { start; end'; options } -> serialize writer start end' options

        let to_proto t = to_proto' (Runtime'.Writer.init ()) t
        let from_proto_exn =
          let constructor = fun start end' options -> { start; end'; options } in
          Runtime'.Deserialize.deserialize (spec ()) constructor
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json ?enum_names ?json_names ?omit_default_values =
          let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
          fun { start; end'; options } -> serialize start end' options
        let from_json_exn =
          let constructor = fun start end' options -> { start; end'; options } in
          Runtime'.Deserialize_json.deserialize (spec ()) constructor
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end
      and ReservedRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option }
        val make: ?start:int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end = struct
        let name' () = "descriptor.google.protobuf.DescriptorProto.ReservedRange"
        type t = { start: int option; end': int option }
        let make ?start ?end' () = { start; end' }
        let merge = (fun t1 t2 -> {
          start = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "start", "start"), int32_int) ) t1.start t2.start);
          end' = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "end", "end"), int32_int) ) t1.end' t2.end');
           })
        let spec () = Runtime'.Spec.( basic_opt ((1, "start", "start"), int32_int) ^:: basic_opt ((2, "end", "end"), int32_int) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.Serialize.serialize (spec ()) in
          fun writer { start; end' } -> serialize writer start end'

        let to_proto t = to_proto' (Runtime'.Writer.init ()) t
        let from_proto_exn =
          let constructor = fun start end' -> { start; end' } in
          Runtime'.Deserialize.deserialize (spec ()) constructor
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json ?enum_names ?json_names ?omit_default_values =
          let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
          fun { start; end' } -> serialize start end'
        let from_json_exn =
          let constructor = fun start end' -> { start; end' } in
          Runtime'.Deserialize_json.deserialize (spec ()) constructor
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end
      let name' () = "descriptor.google.protobuf.DescriptorProto"
      type t = { name: string option; field: FieldDescriptorProto.t list; nested_type: DescriptorProto.t list; enum_type: EnumDescriptorProto.t list; extension_range: ExtensionRange.t list; extension: FieldDescriptorProto.t list; options: MessageOptions.t option; oneof_decl: OneofDescriptorProto.t list; reserved_range: ReservedRange.t list; reserved_name: string list }
      let make ?name ?(field = []) ?(nested_type = []) ?(enum_type = []) ?(extension_range = []) ?(extension = []) ?options ?(oneof_decl = []) ?(reserved_range = []) ?(reserved_name = []) () = { name; field; nested_type; enum_type; extension_range; extension; options; oneof_decl; reserved_range; reserved_name }
      let merge = (fun t1 t2 -> {
        name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ) t1.name t2.name);
        field = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "field", "field"), (message (module FieldDescriptorProto)), not_packed) ) t1.field t2.field);
        nested_type = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((3, "nested_type", "nestedType"), (message (module DescriptorProto)), not_packed) ) t1.nested_type t2.nested_type);
        enum_type = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((4, "enum_type", "enumType"), (message (module EnumDescriptorProto)), not_packed) ) t1.enum_type t2.enum_type);
        extension_range = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((5, "extension_range", "extensionRange"), (message (module ExtensionRange)), not_packed) ) t1.extension_range t2.extension_range);
        extension = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((6, "extension", "extension"), (message (module FieldDescriptorProto)), not_packed) ) t1.extension t2.extension);
        options = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((7, "options", "options"), (message (module MessageOptions))) ) t1.options t2.options);
        oneof_decl = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((8, "oneof_decl", "oneofDecl"), (message (module OneofDescriptorProto)), not_packed) ) t1.oneof_decl t2.oneof_decl);
        reserved_range = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((9, "reserved_range", "reservedRange"), (message (module ReservedRange)), not_packed) ) t1.reserved_range t2.reserved_range);
        reserved_name = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((10, "reserved_name", "reservedName"), string, not_packed) ) t1.reserved_name t2.reserved_name);
         })
      let spec () = Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ^:: repeated ((2, "field", "field"), (message (module FieldDescriptorProto)), not_packed) ^:: repeated ((3, "nested_type", "nestedType"), (message (module DescriptorProto)), not_packed) ^:: repeated ((4, "enum_type", "enumType"), (message (module EnumDescriptorProto)), not_packed) ^:: repeated ((5, "extension_range", "extensionRange"), (message (module ExtensionRange)), not_packed) ^:: repeated ((6, "extension", "extension"), (message (module FieldDescriptorProto)), not_packed) ^:: basic_opt ((7, "options", "options"), (message (module MessageOptions))) ^:: repeated ((8, "oneof_decl", "oneofDecl"), (message (module OneofDescriptorProto)), not_packed) ^:: repeated ((9, "reserved_range", "reservedRange"), (message (module ReservedRange)), not_packed) ^:: repeated ((10, "reserved_name", "reservedName"), string, not_packed) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { name; field; nested_type; enum_type; extension_range; extension; options; oneof_decl; reserved_range; reserved_name } -> serialize writer name field nested_type enum_type extension_range extension options oneof_decl reserved_range reserved_name

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun name field nested_type enum_type extension_range extension options oneof_decl reserved_range reserved_name -> { name; field; nested_type; enum_type; extension_range; extension; options; oneof_decl; reserved_range; reserved_name } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { name; field; nested_type; enum_type; extension_range; extension; options; oneof_decl; reserved_range; reserved_name } -> serialize name field nested_type enum_type extension_range extension options oneof_decl reserved_range reserved_name
      let from_json_exn =
        let constructor = fun name field nested_type enum_type extension_range extension options oneof_decl reserved_range reserved_name -> { name; field; nested_type; enum_type; extension_range; extension; options; oneof_decl; reserved_range; reserved_name } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and ExtensionRangeOptions : sig
      val name': unit -> string
      type t = { uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.ExtensionRangeOptions"
      type t = { uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      let make ?(uninterpreted_option = []) ?(extensions' = Runtime'.Extensions.default) () = { uninterpreted_option; extensions' }
      let merge = (fun t1 t2 -> {
        uninterpreted_option = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ) t1.uninterpreted_option t2.uninterpreted_option);
        extensions' = (List.append t1.extensions' t2.extensions');
         })
      let spec () = Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ^:: nil_ext [ (1000, 536870912) ] )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { uninterpreted_option; extensions' } -> serialize writer uninterpreted_option extensions'

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun uninterpreted_option extensions' -> { uninterpreted_option; extensions' } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { uninterpreted_option; extensions' } -> serialize uninterpreted_option extensions'
      let from_json_exn =
        let constructor = fun uninterpreted_option extensions' -> { uninterpreted_option; extensions' } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and FieldDescriptorProto : sig
      module rec Type : sig
        type t = TYPE_DOUBLE | TYPE_FLOAT | TYPE_INT64 | TYPE_UINT64 | TYPE_INT32 | TYPE_FIXED64 | TYPE_FIXED32 | TYPE_BOOL | TYPE_STRING | TYPE_GROUP | TYPE_MESSAGE | TYPE_BYTES | TYPE_UINT32 | TYPE_ENUM | TYPE_SFIXED32 | TYPE_SFIXED64 | TYPE_SINT32 | TYPE_SINT64
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      and Label : sig
        type t = LABEL_OPTIONAL | LABEL_REQUIRED | LABEL_REPEATED
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { name: string option; extendee: string option; number: int option; label: Label.t option; type': Type.t option; type_name: string option; default_value: string option; options: FieldOptions.t option; oneof_index: int option; json_name: string option; proto3_optional: bool option }
      val make: ?name:string -> ?extendee:string -> ?number:int -> ?label:Label.t -> ?type':Type.t -> ?type_name:string -> ?default_value:string -> ?options:FieldOptions.t -> ?oneof_index:int -> ?json_name:string -> ?proto3_optional:bool -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      module rec Type : sig
        type t = TYPE_DOUBLE | TYPE_FLOAT | TYPE_INT64 | TYPE_UINT64 | TYPE_INT32 | TYPE_FIXED64 | TYPE_FIXED32 | TYPE_BOOL | TYPE_STRING | TYPE_GROUP | TYPE_MESSAGE | TYPE_BYTES | TYPE_UINT32 | TYPE_ENUM | TYPE_SFIXED32 | TYPE_SFIXED64 | TYPE_SINT32 | TYPE_SINT64
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end = struct
        type t = TYPE_DOUBLE | TYPE_FLOAT | TYPE_INT64 | TYPE_UINT64 | TYPE_INT32 | TYPE_FIXED64 | TYPE_FIXED32 | TYPE_BOOL | TYPE_STRING | TYPE_GROUP | TYPE_MESSAGE | TYPE_BYTES | TYPE_UINT32 | TYPE_ENUM | TYPE_SFIXED32 | TYPE_SFIXED64 | TYPE_SINT32 | TYPE_SINT64
        let to_int = function
          | TYPE_DOUBLE -> 1
          | TYPE_FLOAT -> 2
          | TYPE_INT64 -> 3
          | TYPE_UINT64 -> 4
          | TYPE_INT32 -> 5
          | TYPE_FIXED64 -> 6
          | TYPE_FIXED32 -> 7
          | TYPE_BOOL -> 8
          | TYPE_STRING -> 9
          | TYPE_GROUP -> 10
          | TYPE_MESSAGE -> 11
          | TYPE_BYTES -> 12
          | TYPE_UINT32 -> 13
          | TYPE_ENUM -> 14
          | TYPE_SFIXED32 -> 15
          | TYPE_SFIXED64 -> 16
          | TYPE_SINT32 -> 17
          | TYPE_SINT64 -> 18
        let from_int_exn = function
          | 1 -> TYPE_DOUBLE
          | 2 -> TYPE_FLOAT
          | 3 -> TYPE_INT64
          | 4 -> TYPE_UINT64
          | 5 -> TYPE_INT32
          | 6 -> TYPE_FIXED64
          | 7 -> TYPE_FIXED32
          | 8 -> TYPE_BOOL
          | 9 -> TYPE_STRING
          | 10 -> TYPE_GROUP
          | 11 -> TYPE_MESSAGE
          | 12 -> TYPE_BYTES
          | 13 -> TYPE_UINT32
          | 14 -> TYPE_ENUM
          | 15 -> TYPE_SFIXED32
          | 16 -> TYPE_SFIXED64
          | 17 -> TYPE_SINT32
          | 18 -> TYPE_SINT64
          | n -> Runtime'.Result.raise (`Unknown_enum_value n)
        let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
        let to_string = function
          | TYPE_DOUBLE -> "TYPE_DOUBLE"
          | TYPE_FLOAT -> "TYPE_FLOAT"
          | TYPE_INT64 -> "TYPE_INT64"
          | TYPE_UINT64 -> "TYPE_UINT64"
          | TYPE_INT32 -> "TYPE_INT32"
          | TYPE_FIXED64 -> "TYPE_FIXED64"
          | TYPE_FIXED32 -> "TYPE_FIXED32"
          | TYPE_BOOL -> "TYPE_BOOL"
          | TYPE_STRING -> "TYPE_STRING"
          | TYPE_GROUP -> "TYPE_GROUP"
          | TYPE_MESSAGE -> "TYPE_MESSAGE"
          | TYPE_BYTES -> "TYPE_BYTES"
          | TYPE_UINT32 -> "TYPE_UINT32"
          | TYPE_ENUM -> "TYPE_ENUM"
          | TYPE_SFIXED32 -> "TYPE_SFIXED32"
          | TYPE_SFIXED64 -> "TYPE_SFIXED64"
          | TYPE_SINT32 -> "TYPE_SINT32"
          | TYPE_SINT64 -> "TYPE_SINT64"
        let from_string_exn = function
          | "TYPE_DOUBLE" -> TYPE_DOUBLE
          | "TYPE_FLOAT" -> TYPE_FLOAT
          | "TYPE_INT64" -> TYPE_INT64
          | "TYPE_UINT64" -> TYPE_UINT64
          | "TYPE_INT32" -> TYPE_INT32
          | "TYPE_FIXED64" -> TYPE_FIXED64
          | "TYPE_FIXED32" -> TYPE_FIXED32
          | "TYPE_BOOL" -> TYPE_BOOL
          | "TYPE_STRING" -> TYPE_STRING
          | "TYPE_GROUP" -> TYPE_GROUP
          | "TYPE_MESSAGE" -> TYPE_MESSAGE
          | "TYPE_BYTES" -> TYPE_BYTES
          | "TYPE_UINT32" -> TYPE_UINT32
          | "TYPE_ENUM" -> TYPE_ENUM
          | "TYPE_SFIXED32" -> TYPE_SFIXED32
          | "TYPE_SFIXED64" -> TYPE_SFIXED64
          | "TYPE_SINT32" -> TYPE_SINT32
          | "TYPE_SINT64" -> TYPE_SINT64
          | s -> Runtime'.Result.raise (`Unknown_enum_name s)

      end
      and Label : sig
        type t = LABEL_OPTIONAL | LABEL_REQUIRED | LABEL_REPEATED
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end = struct
        type t = LABEL_OPTIONAL | LABEL_REQUIRED | LABEL_REPEATED
        let to_int = function
          | LABEL_OPTIONAL -> 1
          | LABEL_REQUIRED -> 2
          | LABEL_REPEATED -> 3
        let from_int_exn = function
          | 1 -> LABEL_OPTIONAL
          | 2 -> LABEL_REQUIRED
          | 3 -> LABEL_REPEATED
          | n -> Runtime'.Result.raise (`Unknown_enum_value n)
        let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
        let to_string = function
          | LABEL_OPTIONAL -> "LABEL_OPTIONAL"
          | LABEL_REQUIRED -> "LABEL_REQUIRED"
          | LABEL_REPEATED -> "LABEL_REPEATED"
        let from_string_exn = function
          | "LABEL_OPTIONAL" -> LABEL_OPTIONAL
          | "LABEL_REQUIRED" -> LABEL_REQUIRED
          | "LABEL_REPEATED" -> LABEL_REPEATED
          | s -> Runtime'.Result.raise (`Unknown_enum_name s)

      end
      let name' () = "descriptor.google.protobuf.FieldDescriptorProto"
      type t = { name: string option; extendee: string option; number: int option; label: Label.t option; type': Type.t option; type_name: string option; default_value: string option; options: FieldOptions.t option; oneof_index: int option; json_name: string option; proto3_optional: bool option }
      let make ?name ?extendee ?number ?label ?type' ?type_name ?default_value ?options ?oneof_index ?json_name ?proto3_optional () = { name; extendee; number; label; type'; type_name; default_value; options; oneof_index; json_name; proto3_optional }
      let merge = (fun t1 t2 -> {
        name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ) t1.name t2.name);
        extendee = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "extendee", "extendee"), string) ) t1.extendee t2.extendee);
        number = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "number", "number"), int32_int) ) t1.number t2.number);
        label = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((4, "label", "label"), (enum (module Label))) ) t1.label t2.label);
        type' = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((5, "type", "type"), (enum (module Type))) ) t1.type' t2.type');
        type_name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((6, "type_name", "typeName"), string) ) t1.type_name t2.type_name);
        default_value = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((7, "default_value", "defaultValue"), string) ) t1.default_value t2.default_value);
        options = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((8, "options", "options"), (message (module FieldOptions))) ) t1.options t2.options);
        oneof_index = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((9, "oneof_index", "oneofIndex"), int32_int) ) t1.oneof_index t2.oneof_index);
        json_name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((10, "json_name", "jsonName"), string) ) t1.json_name t2.json_name);
        proto3_optional = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((17, "proto3_optional", "proto3Optional"), bool) ) t1.proto3_optional t2.proto3_optional);
         })
      let spec () = Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ^:: basic_opt ((2, "extendee", "extendee"), string) ^:: basic_opt ((3, "number", "number"), int32_int) ^:: basic_opt ((4, "label", "label"), (enum (module Label))) ^:: basic_opt ((5, "type", "type"), (enum (module Type))) ^:: basic_opt ((6, "type_name", "typeName"), string) ^:: basic_opt ((7, "default_value", "defaultValue"), string) ^:: basic_opt ((8, "options", "options"), (message (module FieldOptions))) ^:: basic_opt ((9, "oneof_index", "oneofIndex"), int32_int) ^:: basic_opt ((10, "json_name", "jsonName"), string) ^:: basic_opt ((17, "proto3_optional", "proto3Optional"), bool) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { name; extendee; number; label; type'; type_name; default_value; options; oneof_index; json_name; proto3_optional } -> serialize writer name extendee number label type' type_name default_value options oneof_index json_name proto3_optional

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun name extendee number label type' type_name default_value options oneof_index json_name proto3_optional -> { name; extendee; number; label; type'; type_name; default_value; options; oneof_index; json_name; proto3_optional } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { name; extendee; number; label; type'; type_name; default_value; options; oneof_index; json_name; proto3_optional } -> serialize name extendee number label type' type_name default_value options oneof_index json_name proto3_optional
      let from_json_exn =
        let constructor = fun name extendee number label type' type_name default_value options oneof_index json_name proto3_optional -> { name; extendee; number; label; type'; type_name; default_value; options; oneof_index; json_name; proto3_optional } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and OneofDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; options: OneofOptions.t option }
      val make: ?name:string -> ?options:OneofOptions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.OneofDescriptorProto"
      type t = { name: string option; options: OneofOptions.t option }
      let make ?name ?options () = { name; options }
      let merge = (fun t1 t2 -> {
        name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ) t1.name t2.name);
        options = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "options", "options"), (message (module OneofOptions))) ) t1.options t2.options);
         })
      let spec () = Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ^:: basic_opt ((2, "options", "options"), (message (module OneofOptions))) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { name; options } -> serialize writer name options

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun name options -> { name; options } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { name; options } -> serialize name options
      let from_json_exn =
        let constructor = fun name options -> { name; options } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and EnumDescriptorProto : sig
      module rec EnumReservedRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option }
        val make: ?start:int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { name: string option; value: EnumValueDescriptorProto.t list; options: EnumOptions.t option; reserved_range: EnumReservedRange.t list; reserved_name: string list }
      val make: ?name:string -> ?value:EnumValueDescriptorProto.t list -> ?options:EnumOptions.t -> ?reserved_range:EnumReservedRange.t list -> ?reserved_name:string list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      module rec EnumReservedRange : sig
        val name': unit -> string
        type t = { start: int option; end': int option }
        val make: ?start:int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end = struct
        let name' () = "descriptor.google.protobuf.EnumDescriptorProto.EnumReservedRange"
        type t = { start: int option; end': int option }
        let make ?start ?end' () = { start; end' }
        let merge = (fun t1 t2 -> {
          start = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "start", "start"), int32_int) ) t1.start t2.start);
          end' = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "end", "end"), int32_int) ) t1.end' t2.end');
           })
        let spec () = Runtime'.Spec.( basic_opt ((1, "start", "start"), int32_int) ^:: basic_opt ((2, "end", "end"), int32_int) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.Serialize.serialize (spec ()) in
          fun writer { start; end' } -> serialize writer start end'

        let to_proto t = to_proto' (Runtime'.Writer.init ()) t
        let from_proto_exn =
          let constructor = fun start end' -> { start; end' } in
          Runtime'.Deserialize.deserialize (spec ()) constructor
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json ?enum_names ?json_names ?omit_default_values =
          let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
          fun { start; end' } -> serialize start end'
        let from_json_exn =
          let constructor = fun start end' -> { start; end' } in
          Runtime'.Deserialize_json.deserialize (spec ()) constructor
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end
      let name' () = "descriptor.google.protobuf.EnumDescriptorProto"
      type t = { name: string option; value: EnumValueDescriptorProto.t list; options: EnumOptions.t option; reserved_range: EnumReservedRange.t list; reserved_name: string list }
      let make ?name ?(value = []) ?options ?(reserved_range = []) ?(reserved_name = []) () = { name; value; options; reserved_range; reserved_name }
      let merge = (fun t1 t2 -> {
        name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ) t1.name t2.name);
        value = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "value", "value"), (message (module EnumValueDescriptorProto)), not_packed) ) t1.value t2.value);
        options = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "options", "options"), (message (module EnumOptions))) ) t1.options t2.options);
        reserved_range = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((4, "reserved_range", "reservedRange"), (message (module EnumReservedRange)), not_packed) ) t1.reserved_range t2.reserved_range);
        reserved_name = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((5, "reserved_name", "reservedName"), string, not_packed) ) t1.reserved_name t2.reserved_name);
         })
      let spec () = Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ^:: repeated ((2, "value", "value"), (message (module EnumValueDescriptorProto)), not_packed) ^:: basic_opt ((3, "options", "options"), (message (module EnumOptions))) ^:: repeated ((4, "reserved_range", "reservedRange"), (message (module EnumReservedRange)), not_packed) ^:: repeated ((5, "reserved_name", "reservedName"), string, not_packed) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { name; value; options; reserved_range; reserved_name } -> serialize writer name value options reserved_range reserved_name

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun name value options reserved_range reserved_name -> { name; value; options; reserved_range; reserved_name } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { name; value; options; reserved_range; reserved_name } -> serialize name value options reserved_range reserved_name
      let from_json_exn =
        let constructor = fun name value options reserved_range reserved_name -> { name; value; options; reserved_range; reserved_name } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and EnumValueDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; number: int option; options: EnumValueOptions.t option }
      val make: ?name:string -> ?number:int -> ?options:EnumValueOptions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.EnumValueDescriptorProto"
      type t = { name: string option; number: int option; options: EnumValueOptions.t option }
      let make ?name ?number ?options () = { name; number; options }
      let merge = (fun t1 t2 -> {
        name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ) t1.name t2.name);
        number = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "number", "number"), int32_int) ) t1.number t2.number);
        options = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "options", "options"), (message (module EnumValueOptions))) ) t1.options t2.options);
         })
      let spec () = Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ^:: basic_opt ((2, "number", "number"), int32_int) ^:: basic_opt ((3, "options", "options"), (message (module EnumValueOptions))) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { name; number; options } -> serialize writer name number options

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun name number options -> { name; number; options } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { name; number; options } -> serialize name number options
      let from_json_exn =
        let constructor = fun name number options -> { name; number; options } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and ServiceDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; method': MethodDescriptorProto.t list; options: ServiceOptions.t option }
      val make: ?name:string -> ?method':MethodDescriptorProto.t list -> ?options:ServiceOptions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.ServiceDescriptorProto"
      type t = { name: string option; method': MethodDescriptorProto.t list; options: ServiceOptions.t option }
      let make ?name ?(method' = []) ?options () = { name; method'; options }
      let merge = (fun t1 t2 -> {
        name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ) t1.name t2.name);
        method' = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "method", "method"), (message (module MethodDescriptorProto)), not_packed) ) t1.method' t2.method');
        options = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "options", "options"), (message (module ServiceOptions))) ) t1.options t2.options);
         })
      let spec () = Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ^:: repeated ((2, "method", "method"), (message (module MethodDescriptorProto)), not_packed) ^:: basic_opt ((3, "options", "options"), (message (module ServiceOptions))) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { name; method'; options } -> serialize writer name method' options

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun name method' options -> { name; method'; options } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { name; method'; options } -> serialize name method' options
      let from_json_exn =
        let constructor = fun name method' options -> { name; method'; options } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and MethodDescriptorProto : sig
      val name': unit -> string
      type t = { name: string option; input_type: string option; output_type: string option; options: MethodOptions.t option; client_streaming: bool; server_streaming: bool }
      val make: ?name:string -> ?input_type:string -> ?output_type:string -> ?options:MethodOptions.t -> ?client_streaming:bool -> ?server_streaming:bool -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.MethodDescriptorProto"
      type t = { name: string option; input_type: string option; output_type: string option; options: MethodOptions.t option; client_streaming: bool; server_streaming: bool }
      let make ?name ?input_type ?output_type ?options ?(client_streaming = false) ?(server_streaming = false) () = { name; input_type; output_type; options; client_streaming; server_streaming }
      let merge = (fun t1 t2 -> {
        name = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ) t1.name t2.name);
        input_type = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "input_type", "inputType"), string) ) t1.input_type t2.input_type);
        output_type = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "output_type", "outputType"), string) ) t1.output_type t2.output_type);
        options = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((4, "options", "options"), (message (module MethodOptions))) ) t1.options t2.options);
        client_streaming = (Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "client_streaming", "clientStreaming"), bool, (false)) ) t1.client_streaming t2.client_streaming);
        server_streaming = (Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "server_streaming", "serverStreaming"), bool, (false)) ) t1.server_streaming t2.server_streaming);
         })
      let spec () = Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ^:: basic_opt ((2, "input_type", "inputType"), string) ^:: basic_opt ((3, "output_type", "outputType"), string) ^:: basic_opt ((4, "options", "options"), (message (module MethodOptions))) ^:: basic ((5, "client_streaming", "clientStreaming"), bool, (false)) ^:: basic ((6, "server_streaming", "serverStreaming"), bool, (false)) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { name; input_type; output_type; options; client_streaming; server_streaming } -> serialize writer name input_type output_type options client_streaming server_streaming

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun name input_type output_type options client_streaming server_streaming -> { name; input_type; output_type; options; client_streaming; server_streaming } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { name; input_type; output_type; options; client_streaming; server_streaming } -> serialize name input_type output_type options client_streaming server_streaming
      let from_json_exn =
        let constructor = fun name input_type output_type options client_streaming server_streaming -> { name; input_type; output_type; options; client_streaming; server_streaming } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and FileOptions : sig
      module rec OptimizeMode : sig
        type t = SPEED | CODE_SIZE | LITE_RUNTIME
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { java_package: string option; java_outer_classname: string option; optimize_for: OptimizeMode.t; java_multiple_files: bool; go_package: string option; cc_generic_services: bool; java_generic_services: bool; py_generic_services: bool; java_generate_equals_and_hash: bool option; deprecated: bool; java_string_check_utf8: bool; cc_enable_arenas: bool; objc_class_prefix: string option; csharp_namespace: string option; swift_prefix: string option; php_class_prefix: string option; php_namespace: string option; php_generic_services: bool; php_metadata_namespace: string option; ruby_package: string option; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?java_package:string -> ?java_outer_classname:string -> ?optimize_for:OptimizeMode.t -> ?java_multiple_files:bool -> ?go_package:string -> ?cc_generic_services:bool -> ?java_generic_services:bool -> ?py_generic_services:bool -> ?java_generate_equals_and_hash:bool -> ?deprecated:bool -> ?java_string_check_utf8:bool -> ?cc_enable_arenas:bool -> ?objc_class_prefix:string -> ?csharp_namespace:string -> ?swift_prefix:string -> ?php_class_prefix:string -> ?php_namespace:string -> ?php_generic_services:bool -> ?php_metadata_namespace:string -> ?ruby_package:string -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      module rec OptimizeMode : sig
        type t = SPEED | CODE_SIZE | LITE_RUNTIME
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end = struct
        type t = SPEED | CODE_SIZE | LITE_RUNTIME
        let to_int = function
          | SPEED -> 1
          | CODE_SIZE -> 2
          | LITE_RUNTIME -> 3
        let from_int_exn = function
          | 1 -> SPEED
          | 2 -> CODE_SIZE
          | 3 -> LITE_RUNTIME
          | n -> Runtime'.Result.raise (`Unknown_enum_value n)
        let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
        let to_string = function
          | SPEED -> "SPEED"
          | CODE_SIZE -> "CODE_SIZE"
          | LITE_RUNTIME -> "LITE_RUNTIME"
        let from_string_exn = function
          | "SPEED" -> SPEED
          | "CODE_SIZE" -> CODE_SIZE
          | "LITE_RUNTIME" -> LITE_RUNTIME
          | s -> Runtime'.Result.raise (`Unknown_enum_name s)

      end
      let name' () = "descriptor.google.protobuf.FileOptions"
      type t = { java_package: string option; java_outer_classname: string option; optimize_for: OptimizeMode.t; java_multiple_files: bool; go_package: string option; cc_generic_services: bool; java_generic_services: bool; py_generic_services: bool; java_generate_equals_and_hash: bool option; deprecated: bool; java_string_check_utf8: bool; cc_enable_arenas: bool; objc_class_prefix: string option; csharp_namespace: string option; swift_prefix: string option; php_class_prefix: string option; php_namespace: string option; php_generic_services: bool; php_metadata_namespace: string option; ruby_package: string option; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      let make ?java_package ?java_outer_classname ?(optimize_for = OptimizeMode.SPEED) ?(java_multiple_files = false) ?go_package ?(cc_generic_services = false) ?(java_generic_services = false) ?(py_generic_services = false) ?java_generate_equals_and_hash ?(deprecated = false) ?(java_string_check_utf8 = false) ?(cc_enable_arenas = true) ?objc_class_prefix ?csharp_namespace ?swift_prefix ?php_class_prefix ?php_namespace ?(php_generic_services = false) ?php_metadata_namespace ?ruby_package ?(uninterpreted_option = []) ?(extensions' = Runtime'.Extensions.default) () = { java_package; java_outer_classname; optimize_for; java_multiple_files; go_package; cc_generic_services; java_generic_services; py_generic_services; java_generate_equals_and_hash; deprecated; java_string_check_utf8; cc_enable_arenas; objc_class_prefix; csharp_namespace; swift_prefix; php_class_prefix; php_namespace; php_generic_services; php_metadata_namespace; ruby_package; uninterpreted_option; extensions' }
      let merge = (fun t1 t2 -> {
        java_package = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "java_package", "javaPackage"), string) ) t1.java_package t2.java_package);
        java_outer_classname = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((8, "java_outer_classname", "javaOuterClassname"), string) ) t1.java_outer_classname t2.java_outer_classname);
        optimize_for = (Runtime'.Merge.merge Runtime'.Spec.( basic ((9, "optimize_for", "optimizeFor"), (enum (module OptimizeMode)), (OptimizeMode.SPEED)) ) t1.optimize_for t2.optimize_for);
        java_multiple_files = (Runtime'.Merge.merge Runtime'.Spec.( basic ((10, "java_multiple_files", "javaMultipleFiles"), bool, (false)) ) t1.java_multiple_files t2.java_multiple_files);
        go_package = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((11, "go_package", "goPackage"), string) ) t1.go_package t2.go_package);
        cc_generic_services = (Runtime'.Merge.merge Runtime'.Spec.( basic ((16, "cc_generic_services", "ccGenericServices"), bool, (false)) ) t1.cc_generic_services t2.cc_generic_services);
        java_generic_services = (Runtime'.Merge.merge Runtime'.Spec.( basic ((17, "java_generic_services", "javaGenericServices"), bool, (false)) ) t1.java_generic_services t2.java_generic_services);
        py_generic_services = (Runtime'.Merge.merge Runtime'.Spec.( basic ((18, "py_generic_services", "pyGenericServices"), bool, (false)) ) t1.py_generic_services t2.py_generic_services);
        java_generate_equals_and_hash = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((20, "java_generate_equals_and_hash", "javaGenerateEqualsAndHash"), bool) ) t1.java_generate_equals_and_hash t2.java_generate_equals_and_hash);
        deprecated = (Runtime'.Merge.merge Runtime'.Spec.( basic ((23, "deprecated", "deprecated"), bool, (false)) ) t1.deprecated t2.deprecated);
        java_string_check_utf8 = (Runtime'.Merge.merge Runtime'.Spec.( basic ((27, "java_string_check_utf8", "javaStringCheckUtf8"), bool, (false)) ) t1.java_string_check_utf8 t2.java_string_check_utf8);
        cc_enable_arenas = (Runtime'.Merge.merge Runtime'.Spec.( basic ((31, "cc_enable_arenas", "ccEnableArenas"), bool, (true)) ) t1.cc_enable_arenas t2.cc_enable_arenas);
        objc_class_prefix = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((36, "objc_class_prefix", "objcClassPrefix"), string) ) t1.objc_class_prefix t2.objc_class_prefix);
        csharp_namespace = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((37, "csharp_namespace", "csharpNamespace"), string) ) t1.csharp_namespace t2.csharp_namespace);
        swift_prefix = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((39, "swift_prefix", "swiftPrefix"), string) ) t1.swift_prefix t2.swift_prefix);
        php_class_prefix = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((40, "php_class_prefix", "phpClassPrefix"), string) ) t1.php_class_prefix t2.php_class_prefix);
        php_namespace = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((41, "php_namespace", "phpNamespace"), string) ) t1.php_namespace t2.php_namespace);
        php_generic_services = (Runtime'.Merge.merge Runtime'.Spec.( basic ((42, "php_generic_services", "phpGenericServices"), bool, (false)) ) t1.php_generic_services t2.php_generic_services);
        php_metadata_namespace = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((44, "php_metadata_namespace", "phpMetadataNamespace"), string) ) t1.php_metadata_namespace t2.php_metadata_namespace);
        ruby_package = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((45, "ruby_package", "rubyPackage"), string) ) t1.ruby_package t2.ruby_package);
        uninterpreted_option = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ) t1.uninterpreted_option t2.uninterpreted_option);
        extensions' = (List.append t1.extensions' t2.extensions');
         })
      let spec () = Runtime'.Spec.( basic_opt ((1, "java_package", "javaPackage"), string) ^:: basic_opt ((8, "java_outer_classname", "javaOuterClassname"), string) ^:: basic ((9, "optimize_for", "optimizeFor"), (enum (module OptimizeMode)), (OptimizeMode.SPEED)) ^:: basic ((10, "java_multiple_files", "javaMultipleFiles"), bool, (false)) ^:: basic_opt ((11, "go_package", "goPackage"), string) ^:: basic ((16, "cc_generic_services", "ccGenericServices"), bool, (false)) ^:: basic ((17, "java_generic_services", "javaGenericServices"), bool, (false)) ^:: basic ((18, "py_generic_services", "pyGenericServices"), bool, (false)) ^:: basic_opt ((20, "java_generate_equals_and_hash", "javaGenerateEqualsAndHash"), bool) ^:: basic ((23, "deprecated", "deprecated"), bool, (false)) ^:: basic ((27, "java_string_check_utf8", "javaStringCheckUtf8"), bool, (false)) ^:: basic ((31, "cc_enable_arenas", "ccEnableArenas"), bool, (true)) ^:: basic_opt ((36, "objc_class_prefix", "objcClassPrefix"), string) ^:: basic_opt ((37, "csharp_namespace", "csharpNamespace"), string) ^:: basic_opt ((39, "swift_prefix", "swiftPrefix"), string) ^:: basic_opt ((40, "php_class_prefix", "phpClassPrefix"), string) ^:: basic_opt ((41, "php_namespace", "phpNamespace"), string) ^:: basic ((42, "php_generic_services", "phpGenericServices"), bool, (false)) ^:: basic_opt ((44, "php_metadata_namespace", "phpMetadataNamespace"), string) ^:: basic_opt ((45, "ruby_package", "rubyPackage"), string) ^:: repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ^:: nil_ext [ (1000, 536870912) ] )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { java_package; java_outer_classname; optimize_for; java_multiple_files; go_package; cc_generic_services; java_generic_services; py_generic_services; java_generate_equals_and_hash; deprecated; java_string_check_utf8; cc_enable_arenas; objc_class_prefix; csharp_namespace; swift_prefix; php_class_prefix; php_namespace; php_generic_services; php_metadata_namespace; ruby_package; uninterpreted_option; extensions' } -> serialize writer java_package java_outer_classname optimize_for java_multiple_files go_package cc_generic_services java_generic_services py_generic_services java_generate_equals_and_hash deprecated java_string_check_utf8 cc_enable_arenas objc_class_prefix csharp_namespace swift_prefix php_class_prefix php_namespace php_generic_services php_metadata_namespace ruby_package uninterpreted_option extensions'

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun java_package java_outer_classname optimize_for java_multiple_files go_package cc_generic_services java_generic_services py_generic_services java_generate_equals_and_hash deprecated java_string_check_utf8 cc_enable_arenas objc_class_prefix csharp_namespace swift_prefix php_class_prefix php_namespace php_generic_services php_metadata_namespace ruby_package uninterpreted_option extensions' -> { java_package; java_outer_classname; optimize_for; java_multiple_files; go_package; cc_generic_services; java_generic_services; py_generic_services; java_generate_equals_and_hash; deprecated; java_string_check_utf8; cc_enable_arenas; objc_class_prefix; csharp_namespace; swift_prefix; php_class_prefix; php_namespace; php_generic_services; php_metadata_namespace; ruby_package; uninterpreted_option; extensions' } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { java_package; java_outer_classname; optimize_for; java_multiple_files; go_package; cc_generic_services; java_generic_services; py_generic_services; java_generate_equals_and_hash; deprecated; java_string_check_utf8; cc_enable_arenas; objc_class_prefix; csharp_namespace; swift_prefix; php_class_prefix; php_namespace; php_generic_services; php_metadata_namespace; ruby_package; uninterpreted_option; extensions' } -> serialize java_package java_outer_classname optimize_for java_multiple_files go_package cc_generic_services java_generic_services py_generic_services java_generate_equals_and_hash deprecated java_string_check_utf8 cc_enable_arenas objc_class_prefix csharp_namespace swift_prefix php_class_prefix php_namespace php_generic_services php_metadata_namespace ruby_package uninterpreted_option extensions'
      let from_json_exn =
        let constructor = fun java_package java_outer_classname optimize_for java_multiple_files go_package cc_generic_services java_generic_services py_generic_services java_generate_equals_and_hash deprecated java_string_check_utf8 cc_enable_arenas objc_class_prefix csharp_namespace swift_prefix php_class_prefix php_namespace php_generic_services php_metadata_namespace ruby_package uninterpreted_option extensions' -> { java_package; java_outer_classname; optimize_for; java_multiple_files; go_package; cc_generic_services; java_generic_services; py_generic_services; java_generate_equals_and_hash; deprecated; java_string_check_utf8; cc_enable_arenas; objc_class_prefix; csharp_namespace; swift_prefix; php_class_prefix; php_namespace; php_generic_services; php_metadata_namespace; ruby_package; uninterpreted_option; extensions' } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and MessageOptions : sig
      val name': unit -> string
      type t = { message_set_wire_format: bool; no_standard_descriptor_accessor: bool; deprecated: bool; map_entry: bool option; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?message_set_wire_format:bool -> ?no_standard_descriptor_accessor:bool -> ?deprecated:bool -> ?map_entry:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.MessageOptions"
      type t = { message_set_wire_format: bool; no_standard_descriptor_accessor: bool; deprecated: bool; map_entry: bool option; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      let make ?(message_set_wire_format = false) ?(no_standard_descriptor_accessor = false) ?(deprecated = false) ?map_entry ?(uninterpreted_option = []) ?(extensions' = Runtime'.Extensions.default) () = { message_set_wire_format; no_standard_descriptor_accessor; deprecated; map_entry; uninterpreted_option; extensions' }
      let merge = (fun t1 t2 -> {
        message_set_wire_format = (Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "message_set_wire_format", "messageSetWireFormat"), bool, (false)) ) t1.message_set_wire_format t2.message_set_wire_format);
        no_standard_descriptor_accessor = (Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "no_standard_descriptor_accessor", "noStandardDescriptorAccessor"), bool, (false)) ) t1.no_standard_descriptor_accessor t2.no_standard_descriptor_accessor);
        deprecated = (Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "deprecated", "deprecated"), bool, (false)) ) t1.deprecated t2.deprecated);
        map_entry = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((7, "map_entry", "mapEntry"), bool) ) t1.map_entry t2.map_entry);
        uninterpreted_option = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ) t1.uninterpreted_option t2.uninterpreted_option);
        extensions' = (List.append t1.extensions' t2.extensions');
         })
      let spec () = Runtime'.Spec.( basic ((1, "message_set_wire_format", "messageSetWireFormat"), bool, (false)) ^:: basic ((2, "no_standard_descriptor_accessor", "noStandardDescriptorAccessor"), bool, (false)) ^:: basic ((3, "deprecated", "deprecated"), bool, (false)) ^:: basic_opt ((7, "map_entry", "mapEntry"), bool) ^:: repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ^:: nil_ext [ (1000, 536870912) ] )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { message_set_wire_format; no_standard_descriptor_accessor; deprecated; map_entry; uninterpreted_option; extensions' } -> serialize writer message_set_wire_format no_standard_descriptor_accessor deprecated map_entry uninterpreted_option extensions'

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun message_set_wire_format no_standard_descriptor_accessor deprecated map_entry uninterpreted_option extensions' -> { message_set_wire_format; no_standard_descriptor_accessor; deprecated; map_entry; uninterpreted_option; extensions' } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { message_set_wire_format; no_standard_descriptor_accessor; deprecated; map_entry; uninterpreted_option; extensions' } -> serialize message_set_wire_format no_standard_descriptor_accessor deprecated map_entry uninterpreted_option extensions'
      let from_json_exn =
        let constructor = fun message_set_wire_format no_standard_descriptor_accessor deprecated map_entry uninterpreted_option extensions' -> { message_set_wire_format; no_standard_descriptor_accessor; deprecated; map_entry; uninterpreted_option; extensions' } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and FieldOptions : sig
      module rec CType : sig
        type t = STRING | CORD | STRING_PIECE
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      and JSType : sig
        type t = JS_NORMAL | JS_STRING | JS_NUMBER
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { ctype: CType.t; packed: bool option; deprecated: bool; lazy': bool; jstype: JSType.t; weak: bool; unverified_lazy: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?ctype:CType.t -> ?packed:bool -> ?deprecated:bool -> ?lazy':bool -> ?jstype:JSType.t -> ?weak:bool -> ?unverified_lazy:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      module rec CType : sig
        type t = STRING | CORD | STRING_PIECE
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end = struct
        type t = STRING | CORD | STRING_PIECE
        let to_int = function
          | STRING -> 0
          | CORD -> 1
          | STRING_PIECE -> 2
        let from_int_exn = function
          | 0 -> STRING
          | 1 -> CORD
          | 2 -> STRING_PIECE
          | n -> Runtime'.Result.raise (`Unknown_enum_value n)
        let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
        let to_string = function
          | STRING -> "STRING"
          | CORD -> "CORD"
          | STRING_PIECE -> "STRING_PIECE"
        let from_string_exn = function
          | "STRING" -> STRING
          | "CORD" -> CORD
          | "STRING_PIECE" -> STRING_PIECE
          | s -> Runtime'.Result.raise (`Unknown_enum_name s)

      end
      and JSType : sig
        type t = JS_NORMAL | JS_STRING | JS_NUMBER
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end = struct
        type t = JS_NORMAL | JS_STRING | JS_NUMBER
        let to_int = function
          | JS_NORMAL -> 0
          | JS_STRING -> 1
          | JS_NUMBER -> 2
        let from_int_exn = function
          | 0 -> JS_NORMAL
          | 1 -> JS_STRING
          | 2 -> JS_NUMBER
          | n -> Runtime'.Result.raise (`Unknown_enum_value n)
        let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
        let to_string = function
          | JS_NORMAL -> "JS_NORMAL"
          | JS_STRING -> "JS_STRING"
          | JS_NUMBER -> "JS_NUMBER"
        let from_string_exn = function
          | "JS_NORMAL" -> JS_NORMAL
          | "JS_STRING" -> JS_STRING
          | "JS_NUMBER" -> JS_NUMBER
          | s -> Runtime'.Result.raise (`Unknown_enum_name s)

      end
      let name' () = "descriptor.google.protobuf.FieldOptions"
      type t = { ctype: CType.t; packed: bool option; deprecated: bool; lazy': bool; jstype: JSType.t; weak: bool; unverified_lazy: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      let make ?(ctype = CType.STRING) ?packed ?(deprecated = false) ?(lazy' = false) ?(jstype = JSType.JS_NORMAL) ?(weak = false) ?(unverified_lazy = false) ?(uninterpreted_option = []) ?(extensions' = Runtime'.Extensions.default) () = { ctype; packed; deprecated; lazy'; jstype; weak; unverified_lazy; uninterpreted_option; extensions' }
      let merge = (fun t1 t2 -> {
        ctype = (Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "ctype", "ctype"), (enum (module CType)), (CType.STRING)) ) t1.ctype t2.ctype);
        packed = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "packed", "packed"), bool) ) t1.packed t2.packed);
        deprecated = (Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "deprecated", "deprecated"), bool, (false)) ) t1.deprecated t2.deprecated);
        lazy' = (Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "lazy", "lazy"), bool, (false)) ) t1.lazy' t2.lazy');
        jstype = (Runtime'.Merge.merge Runtime'.Spec.( basic ((6, "jstype", "jstype"), (enum (module JSType)), (JSType.JS_NORMAL)) ) t1.jstype t2.jstype);
        weak = (Runtime'.Merge.merge Runtime'.Spec.( basic ((10, "weak", "weak"), bool, (false)) ) t1.weak t2.weak);
        unverified_lazy = (Runtime'.Merge.merge Runtime'.Spec.( basic ((15, "unverified_lazy", "unverifiedLazy"), bool, (false)) ) t1.unverified_lazy t2.unverified_lazy);
        uninterpreted_option = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ) t1.uninterpreted_option t2.uninterpreted_option);
        extensions' = (List.append t1.extensions' t2.extensions');
         })
      let spec () = Runtime'.Spec.( basic ((1, "ctype", "ctype"), (enum (module CType)), (CType.STRING)) ^:: basic_opt ((2, "packed", "packed"), bool) ^:: basic ((3, "deprecated", "deprecated"), bool, (false)) ^:: basic ((5, "lazy", "lazy"), bool, (false)) ^:: basic ((6, "jstype", "jstype"), (enum (module JSType)), (JSType.JS_NORMAL)) ^:: basic ((10, "weak", "weak"), bool, (false)) ^:: basic ((15, "unverified_lazy", "unverifiedLazy"), bool, (false)) ^:: repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ^:: nil_ext [ (1000, 536870912) ] )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { ctype; packed; deprecated; lazy'; jstype; weak; unverified_lazy; uninterpreted_option; extensions' } -> serialize writer ctype packed deprecated lazy' jstype weak unverified_lazy uninterpreted_option extensions'

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun ctype packed deprecated lazy' jstype weak unverified_lazy uninterpreted_option extensions' -> { ctype; packed; deprecated; lazy'; jstype; weak; unverified_lazy; uninterpreted_option; extensions' } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { ctype; packed; deprecated; lazy'; jstype; weak; unverified_lazy; uninterpreted_option; extensions' } -> serialize ctype packed deprecated lazy' jstype weak unverified_lazy uninterpreted_option extensions'
      let from_json_exn =
        let constructor = fun ctype packed deprecated lazy' jstype weak unverified_lazy uninterpreted_option extensions' -> { ctype; packed; deprecated; lazy'; jstype; weak; unverified_lazy; uninterpreted_option; extensions' } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and OneofOptions : sig
      val name': unit -> string
      type t = { uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.OneofOptions"
      type t = { uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      let make ?(uninterpreted_option = []) ?(extensions' = Runtime'.Extensions.default) () = { uninterpreted_option; extensions' }
      let merge = (fun t1 t2 -> {
        uninterpreted_option = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ) t1.uninterpreted_option t2.uninterpreted_option);
        extensions' = (List.append t1.extensions' t2.extensions');
         })
      let spec () = Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ^:: nil_ext [ (1000, 536870912) ] )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { uninterpreted_option; extensions' } -> serialize writer uninterpreted_option extensions'

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun uninterpreted_option extensions' -> { uninterpreted_option; extensions' } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { uninterpreted_option; extensions' } -> serialize uninterpreted_option extensions'
      let from_json_exn =
        let constructor = fun uninterpreted_option extensions' -> { uninterpreted_option; extensions' } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and EnumOptions : sig
      val name': unit -> string
      type t = { allow_alias: bool option; deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?allow_alias:bool -> ?deprecated:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.EnumOptions"
      type t = { allow_alias: bool option; deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      let make ?allow_alias ?(deprecated = false) ?(uninterpreted_option = []) ?(extensions' = Runtime'.Extensions.default) () = { allow_alias; deprecated; uninterpreted_option; extensions' }
      let merge = (fun t1 t2 -> {
        allow_alias = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "allow_alias", "allowAlias"), bool) ) t1.allow_alias t2.allow_alias);
        deprecated = (Runtime'.Merge.merge Runtime'.Spec.( basic ((3, "deprecated", "deprecated"), bool, (false)) ) t1.deprecated t2.deprecated);
        uninterpreted_option = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ) t1.uninterpreted_option t2.uninterpreted_option);
        extensions' = (List.append t1.extensions' t2.extensions');
         })
      let spec () = Runtime'.Spec.( basic_opt ((2, "allow_alias", "allowAlias"), bool) ^:: basic ((3, "deprecated", "deprecated"), bool, (false)) ^:: repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ^:: nil_ext [ (1000, 536870912) ] )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { allow_alias; deprecated; uninterpreted_option; extensions' } -> serialize writer allow_alias deprecated uninterpreted_option extensions'

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun allow_alias deprecated uninterpreted_option extensions' -> { allow_alias; deprecated; uninterpreted_option; extensions' } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { allow_alias; deprecated; uninterpreted_option; extensions' } -> serialize allow_alias deprecated uninterpreted_option extensions'
      let from_json_exn =
        let constructor = fun allow_alias deprecated uninterpreted_option extensions' -> { allow_alias; deprecated; uninterpreted_option; extensions' } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and EnumValueOptions : sig
      val name': unit -> string
      type t = { deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?deprecated:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.EnumValueOptions"
      type t = { deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      let make ?(deprecated = false) ?(uninterpreted_option = []) ?(extensions' = Runtime'.Extensions.default) () = { deprecated; uninterpreted_option; extensions' }
      let merge = (fun t1 t2 -> {
        deprecated = (Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "deprecated", "deprecated"), bool, (false)) ) t1.deprecated t2.deprecated);
        uninterpreted_option = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ) t1.uninterpreted_option t2.uninterpreted_option);
        extensions' = (List.append t1.extensions' t2.extensions');
         })
      let spec () = Runtime'.Spec.( basic ((1, "deprecated", "deprecated"), bool, (false)) ^:: repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ^:: nil_ext [ (1000, 536870912) ] )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { deprecated; uninterpreted_option; extensions' } -> serialize writer deprecated uninterpreted_option extensions'

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun deprecated uninterpreted_option extensions' -> { deprecated; uninterpreted_option; extensions' } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { deprecated; uninterpreted_option; extensions' } -> serialize deprecated uninterpreted_option extensions'
      let from_json_exn =
        let constructor = fun deprecated uninterpreted_option extensions' -> { deprecated; uninterpreted_option; extensions' } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and ServiceOptions : sig
      val name': unit -> string
      type t = { deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?deprecated:bool -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "descriptor.google.protobuf.ServiceOptions"
      type t = { deprecated: bool; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      let make ?(deprecated = false) ?(uninterpreted_option = []) ?(extensions' = Runtime'.Extensions.default) () = { deprecated; uninterpreted_option; extensions' }
      let merge = (fun t1 t2 -> {
        deprecated = (Runtime'.Merge.merge Runtime'.Spec.( basic ((33, "deprecated", "deprecated"), bool, (false)) ) t1.deprecated t2.deprecated);
        uninterpreted_option = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ) t1.uninterpreted_option t2.uninterpreted_option);
        extensions' = (List.append t1.extensions' t2.extensions');
         })
      let spec () = Runtime'.Spec.( basic ((33, "deprecated", "deprecated"), bool, (false)) ^:: repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ^:: nil_ext [ (1000, 536870912) ] )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { deprecated; uninterpreted_option; extensions' } -> serialize writer deprecated uninterpreted_option extensions'

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun deprecated uninterpreted_option extensions' -> { deprecated; uninterpreted_option; extensions' } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { deprecated; uninterpreted_option; extensions' } -> serialize deprecated uninterpreted_option extensions'
      let from_json_exn =
        let constructor = fun deprecated uninterpreted_option extensions' -> { deprecated; uninterpreted_option; extensions' } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and MethodOptions : sig
      module rec IdempotencyLevel : sig
        type t = IDEMPOTENCY_UNKNOWN | NO_SIDE_EFFECTS | IDEMPOTENT
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end
      val name': unit -> string
      type t = { deprecated: bool; idempotency_level: IdempotencyLevel.t; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      val make: ?deprecated:bool -> ?idempotency_level:IdempotencyLevel.t -> ?uninterpreted_option:UninterpretedOption.t list -> ?extensions':Runtime'.Extensions.t -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      module rec IdempotencyLevel : sig
        type t = IDEMPOTENCY_UNKNOWN | NO_SIDE_EFFECTS | IDEMPOTENT
        val to_int: t -> int
        val from_int: int -> t Runtime'.Result.t
        val from_int_exn: int -> t
        val to_string: t -> string
        val from_string_exn: string -> t
      end = struct
        type t = IDEMPOTENCY_UNKNOWN | NO_SIDE_EFFECTS | IDEMPOTENT
        let to_int = function
          | IDEMPOTENCY_UNKNOWN -> 0
          | NO_SIDE_EFFECTS -> 1
          | IDEMPOTENT -> 2
        let from_int_exn = function
          | 0 -> IDEMPOTENCY_UNKNOWN
          | 1 -> NO_SIDE_EFFECTS
          | 2 -> IDEMPOTENT
          | n -> Runtime'.Result.raise (`Unknown_enum_value n)
        let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
        let to_string = function
          | IDEMPOTENCY_UNKNOWN -> "IDEMPOTENCY_UNKNOWN"
          | NO_SIDE_EFFECTS -> "NO_SIDE_EFFECTS"
          | IDEMPOTENT -> "IDEMPOTENT"
        let from_string_exn = function
          | "IDEMPOTENCY_UNKNOWN" -> IDEMPOTENCY_UNKNOWN
          | "NO_SIDE_EFFECTS" -> NO_SIDE_EFFECTS
          | "IDEMPOTENT" -> IDEMPOTENT
          | s -> Runtime'.Result.raise (`Unknown_enum_name s)

      end
      let name' () = "descriptor.google.protobuf.MethodOptions"
      type t = { deprecated: bool; idempotency_level: IdempotencyLevel.t; uninterpreted_option: UninterpretedOption.t list; extensions': Runtime'.Extensions.t }
      let make ?(deprecated = false) ?(idempotency_level = IdempotencyLevel.IDEMPOTENCY_UNKNOWN) ?(uninterpreted_option = []) ?(extensions' = Runtime'.Extensions.default) () = { deprecated; idempotency_level; uninterpreted_option; extensions' }
      let merge = (fun t1 t2 -> {
        deprecated = (Runtime'.Merge.merge Runtime'.Spec.( basic ((33, "deprecated", "deprecated"), bool, (false)) ) t1.deprecated t2.deprecated);
        idempotency_level = (Runtime'.Merge.merge Runtime'.Spec.( basic ((34, "idempotency_level", "idempotencyLevel"), (enum (module IdempotencyLevel)), (IdempotencyLevel.IDEMPOTENCY_UNKNOWN)) ) t1.idempotency_level t2.idempotency_level);
        uninterpreted_option = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ) t1.uninterpreted_option t2.uninterpreted_option);
        extensions' = (List.append t1.extensions' t2.extensions');
         })
      let spec () = Runtime'.Spec.( basic ((33, "deprecated", "deprecated"), bool, (false)) ^:: basic ((34, "idempotency_level", "idempotencyLevel"), (enum (module IdempotencyLevel)), (IdempotencyLevel.IDEMPOTENCY_UNKNOWN)) ^:: repeated ((999, "uninterpreted_option", "uninterpretedOption"), (message (module UninterpretedOption)), not_packed) ^:: nil_ext [ (1000, 536870912) ] )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { deprecated; idempotency_level; uninterpreted_option; extensions' } -> serialize writer deprecated idempotency_level uninterpreted_option extensions'

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun deprecated idempotency_level uninterpreted_option extensions' -> { deprecated; idempotency_level; uninterpreted_option; extensions' } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { deprecated; idempotency_level; uninterpreted_option; extensions' } -> serialize deprecated idempotency_level uninterpreted_option extensions'
      let from_json_exn =
        let constructor = fun deprecated idempotency_level uninterpreted_option extensions' -> { deprecated; idempotency_level; uninterpreted_option; extensions' } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and UninterpretedOption : sig
      module rec NamePart : sig
        val name': unit -> string
        type t = { name_part: string; is_extension: bool }
        val make: name_part:string -> is_extension:bool -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { name: NamePart.t list; identifier_value: string option; positive_int_value: int option; negative_int_value: int option; double_value: float option; string_value: bytes option; aggregate_value: string option }
      val make: ?name:NamePart.t list -> ?identifier_value:string -> ?positive_int_value:int -> ?negative_int_value:int -> ?double_value:float -> ?string_value:bytes -> ?aggregate_value:string -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      module rec NamePart : sig
        val name': unit -> string
        type t = { name_part: string; is_extension: bool }
        val make: name_part:string -> is_extension:bool -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end = struct
        let name' () = "descriptor.google.protobuf.UninterpretedOption.NamePart"
        type t = { name_part: string; is_extension: bool }
        let make ~name_part ~is_extension () = { name_part; is_extension }
        let merge = (fun t1 t2 -> {
          name_part = (Runtime'.Merge.merge Runtime'.Spec.( basic_req ((1, "name_part", "namePart"), string) ) t1.name_part t2.name_part);
          is_extension = (Runtime'.Merge.merge Runtime'.Spec.( basic_req ((2, "is_extension", "isExtension"), bool) ) t1.is_extension t2.is_extension);
           })
        let spec () = Runtime'.Spec.( basic_req ((1, "name_part", "namePart"), string) ^:: basic_req ((2, "is_extension", "isExtension"), bool) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.Serialize.serialize (spec ()) in
          fun writer { name_part; is_extension } -> serialize writer name_part is_extension

        let to_proto t = to_proto' (Runtime'.Writer.init ()) t
        let from_proto_exn =
          let constructor = fun name_part is_extension -> { name_part; is_extension } in
          Runtime'.Deserialize.deserialize (spec ()) constructor
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json ?enum_names ?json_names ?omit_default_values =
          let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
          fun { name_part; is_extension } -> serialize name_part is_extension
        let from_json_exn =
          let constructor = fun name_part is_extension -> { name_part; is_extension } in
          Runtime'.Deserialize_json.deserialize (spec ()) constructor
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end
      let name' () = "descriptor.google.protobuf.UninterpretedOption"
      type t = { name: NamePart.t list; identifier_value: string option; positive_int_value: int option; negative_int_value: int option; double_value: float option; string_value: bytes option; aggregate_value: string option }
      let make ?(name = []) ?identifier_value ?positive_int_value ?negative_int_value ?double_value ?string_value ?aggregate_value () = { name; identifier_value; positive_int_value; negative_int_value; double_value; string_value; aggregate_value }
      let merge = (fun t1 t2 -> {
        name = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "name", "name"), (message (module NamePart)), not_packed) ) t1.name t2.name);
        identifier_value = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "identifier_value", "identifierValue"), string) ) t1.identifier_value t2.identifier_value);
        positive_int_value = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((4, "positive_int_value", "positiveIntValue"), uint64_int) ) t1.positive_int_value t2.positive_int_value);
        negative_int_value = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((5, "negative_int_value", "negativeIntValue"), int64_int) ) t1.negative_int_value t2.negative_int_value);
        double_value = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((6, "double_value", "doubleValue"), double) ) t1.double_value t2.double_value);
        string_value = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((7, "string_value", "stringValue"), bytes) ) t1.string_value t2.string_value);
        aggregate_value = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((8, "aggregate_value", "aggregateValue"), string) ) t1.aggregate_value t2.aggregate_value);
         })
      let spec () = Runtime'.Spec.( repeated ((2, "name", "name"), (message (module NamePart)), not_packed) ^:: basic_opt ((3, "identifier_value", "identifierValue"), string) ^:: basic_opt ((4, "positive_int_value", "positiveIntValue"), uint64_int) ^:: basic_opt ((5, "negative_int_value", "negativeIntValue"), int64_int) ^:: basic_opt ((6, "double_value", "doubleValue"), double) ^:: basic_opt ((7, "string_value", "stringValue"), bytes) ^:: basic_opt ((8, "aggregate_value", "aggregateValue"), string) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        fun writer { name; identifier_value; positive_int_value; negative_int_value; double_value; string_value; aggregate_value } -> serialize writer name identifier_value positive_int_value negative_int_value double_value string_value aggregate_value

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun name identifier_value positive_int_value negative_int_value double_value string_value aggregate_value -> { name; identifier_value; positive_int_value; negative_int_value; double_value; string_value; aggregate_value } in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        fun { name; identifier_value; positive_int_value; negative_int_value; double_value; string_value; aggregate_value } -> serialize name identifier_value positive_int_value negative_int_value double_value string_value aggregate_value
      let from_json_exn =
        let constructor = fun name identifier_value positive_int_value negative_int_value double_value string_value aggregate_value -> { name; identifier_value; positive_int_value; negative_int_value; double_value; string_value; aggregate_value } in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and SourceCodeInfo : sig
      module rec Location : sig
        val name': unit -> string
        type t = { path: int list; span: int list; leading_comments: string option; trailing_comments: string option; leading_detached_comments: string list }
        val make: ?path:int list -> ?span:int list -> ?leading_comments:string -> ?trailing_comments:string -> ?leading_detached_comments:string list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = (Location.t list)
      val make: ?location:Location.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      module rec Location : sig
        val name': unit -> string
        type t = { path: int list; span: int list; leading_comments: string option; trailing_comments: string option; leading_detached_comments: string list }
        val make: ?path:int list -> ?span:int list -> ?leading_comments:string -> ?trailing_comments:string -> ?leading_detached_comments:string list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end = struct
        let name' () = "descriptor.google.protobuf.SourceCodeInfo.Location"
        type t = { path: int list; span: int list; leading_comments: string option; trailing_comments: string option; leading_detached_comments: string list }
        let make ?(path = []) ?(span = []) ?leading_comments ?trailing_comments ?(leading_detached_comments = []) () = { path; span; leading_comments; trailing_comments; leading_detached_comments }
        let merge = (fun t1 t2 -> {
          path = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "path", "path"), int32_int, packed) ) t1.path t2.path);
          span = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "span", "span"), int32_int, packed) ) t1.span t2.span);
          leading_comments = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "leading_comments", "leadingComments"), string) ) t1.leading_comments t2.leading_comments);
          trailing_comments = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((4, "trailing_comments", "trailingComments"), string) ) t1.trailing_comments t2.trailing_comments);
          leading_detached_comments = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((6, "leading_detached_comments", "leadingDetachedComments"), string, not_packed) ) t1.leading_detached_comments t2.leading_detached_comments);
           })
        let spec () = Runtime'.Spec.( repeated ((1, "path", "path"), int32_int, packed) ^:: repeated ((2, "span", "span"), int32_int, packed) ^:: basic_opt ((3, "leading_comments", "leadingComments"), string) ^:: basic_opt ((4, "trailing_comments", "trailingComments"), string) ^:: repeated ((6, "leading_detached_comments", "leadingDetachedComments"), string, not_packed) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.Serialize.serialize (spec ()) in
          fun writer { path; span; leading_comments; trailing_comments; leading_detached_comments } -> serialize writer path span leading_comments trailing_comments leading_detached_comments

        let to_proto t = to_proto' (Runtime'.Writer.init ()) t
        let from_proto_exn =
          let constructor = fun path span leading_comments trailing_comments leading_detached_comments -> { path; span; leading_comments; trailing_comments; leading_detached_comments } in
          Runtime'.Deserialize.deserialize (spec ()) constructor
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json ?enum_names ?json_names ?omit_default_values =
          let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
          fun { path; span; leading_comments; trailing_comments; leading_detached_comments } -> serialize path span leading_comments trailing_comments leading_detached_comments
        let from_json_exn =
          let constructor = fun path span leading_comments trailing_comments leading_detached_comments -> { path; span; leading_comments; trailing_comments; leading_detached_comments } in
          Runtime'.Deserialize_json.deserialize (spec ()) constructor
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end
      let name' () = "descriptor.google.protobuf.SourceCodeInfo"
      type t = (Location.t list)
      let make ?(location = []) () = (location)
      let merge = (fun (t1_location) (t2_location) -> (Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "location", "location"), (message (module Location)), not_packed) ) t1_location t2_location))
      let spec () = Runtime'.Spec.( repeated ((1, "location", "location"), (message (module Location)), not_packed) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        serialize

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun location -> (location) in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        serialize
      let from_json_exn =
        let constructor = fun location -> (location) in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
    and GeneratedCodeInfo : sig
      module rec Annotation : sig
        val name': unit -> string
        type t = { path: int list; source_file: string option; begin': int option; end': int option }
        val make: ?path:int list -> ?source_file:string -> ?begin':int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = (Annotation.t list)
      val make: ?annotation:Annotation.t list -> unit -> t
      val merge: t -> t -> t
      val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
      val from_proto_exn: Runtime'.Reader.t -> t
      val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
      val from_json_exn: Yojson.Basic.t -> t
      val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      module rec Annotation : sig
        val name': unit -> string
        type t = { path: int list; source_file: string option; begin': int option; end': int option }
        val make: ?path:int list -> ?source_file:string -> ?begin':int -> ?end':int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> Runtime'.Writer.t
        val to_proto: t -> Runtime'.Writer.t
        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        val from_proto_exn: Runtime'.Reader.t -> t
        val to_json: ?enum_names:bool -> ?json_names:bool -> ?omit_default_values:bool -> t -> Yojson.Basic.t
        val from_json_exn: Yojson.Basic.t -> t
        val from_json: Yojson.Basic.t -> (t, [> Runtime'.Result.error]) result
      end = struct
        let name' () = "descriptor.google.protobuf.GeneratedCodeInfo.Annotation"
        type t = { path: int list; source_file: string option; begin': int option; end': int option }
        let make ?(path = []) ?source_file ?begin' ?end' () = { path; source_file; begin'; end' }
        let merge = (fun t1 t2 -> {
          path = (Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "path", "path"), int32_int, packed) ) t1.path t2.path);
          source_file = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "source_file", "sourceFile"), string) ) t1.source_file t2.source_file);
          begin' = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "begin", "begin"), int32_int) ) t1.begin' t2.begin');
          end' = (Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((4, "end", "end"), int32_int) ) t1.end' t2.end');
           })
        let spec () = Runtime'.Spec.( repeated ((1, "path", "path"), int32_int, packed) ^:: basic_opt ((2, "source_file", "sourceFile"), string) ^:: basic_opt ((3, "begin", "begin"), int32_int) ^:: basic_opt ((4, "end", "end"), int32_int) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.Serialize.serialize (spec ()) in
          fun writer { path; source_file; begin'; end' } -> serialize writer path source_file begin' end'

        let to_proto t = to_proto' (Runtime'.Writer.init ()) t
        let from_proto_exn =
          let constructor = fun path source_file begin' end' -> { path; source_file; begin'; end' } in
          Runtime'.Deserialize.deserialize (spec ()) constructor
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json ?enum_names ?json_names ?omit_default_values =
          let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
          fun { path; source_file; begin'; end' } -> serialize path source_file begin' end'
        let from_json_exn =
          let constructor = fun path source_file begin' end' -> { path; source_file; begin'; end' } in
          Runtime'.Deserialize_json.deserialize (spec ()) constructor
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end
      let name' () = "descriptor.google.protobuf.GeneratedCodeInfo"
      type t = (Annotation.t list)
      let make ?(annotation = []) () = (annotation)
      let merge = (fun (t1_annotation) (t2_annotation) -> (Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "annotation", "annotation"), (message (module Annotation)), not_packed) ) t1_annotation t2_annotation))
      let spec () = Runtime'.Spec.( repeated ((1, "annotation", "annotation"), (message (module Annotation)), not_packed) ^:: nil )
      let to_proto' =
        let serialize = Runtime'.Serialize.serialize (spec ()) in
        serialize

      let to_proto t = to_proto' (Runtime'.Writer.init ()) t
      let from_proto_exn =
        let constructor = fun annotation -> (annotation) in
        Runtime'.Deserialize.deserialize (spec ()) constructor
      let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
      let to_json ?enum_names ?json_names ?omit_default_values =
        let serialize = Runtime'.Serialize_json.serialize ?enum_names ?json_names ?omit_default_values (spec ()) in
        serialize
      let from_json_exn =
        let constructor = fun annotation -> (annotation) in
        Runtime'.Deserialize_json.deserialize (spec ()) constructor
      let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
    end
  end
end
