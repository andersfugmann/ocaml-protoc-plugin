(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: google/protobuf/compiler/plugin.proto
  Syntax: proto2
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)
(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
  module Descriptor = Descriptor
end
(**/**)
module rec Google : sig
  module rec Protobuf : sig
    module rec Compiler : sig

      (** The version number of protocol compiler. *)
      module rec Version : sig
        type t = {
          major:int option;
          minor:int option;
          patch:int option;
          suffix:string option;
          (**
            A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
            be empty for mainline stable releases.
          *)

        }
        val make: ?major:int -> ?minor:int -> ?patch:int -> ?suffix:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?major:int -> ?minor:int -> ?patch:int -> ?suffix:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      (** An encoded CodeGeneratorRequest is written to the plugin's stdin. *)
      and CodeGeneratorRequest : sig
        type t = {
          file_to_generate:string list;
          parameter:string option;
          (**
            The generator parameter passed on the command-line.
          *)

          compiler_version:Version.t option;
          proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list;
        }
        val make: ?file_to_generate:string list -> ?parameter:string -> ?compiler_version:Version.t -> ?proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?file_to_generate:string list -> ?parameter:string -> ?compiler_version:Version.t -> ?proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      (** The plugin writes an encoded CodeGeneratorResponse to stdout. *)
      and CodeGeneratorResponse : sig

        (** Sync with code_generator.h. *)
        module rec Feature : sig
          type t =
            | FEATURE_NONE
            | FEATURE_PROTO3_OPTIONAL

          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end

        (** Represents a single generated file. *)
        and File : sig
          type t = {
            name:string option;
            (**
              The file name, relative to the output directory.  The name must not
              contain "." or ".." components and must be relative, not be absolute (so,
              the file cannot lie outside the output directory).  "/" must be used as
              the path separator, not "\\".

              If the name is omitted, the content will be appended to the previous
              file.  This allows the generator to break large files into small chunks,
              and allows the generated text to be streamed back to protoc so that large
              files need not reside completely in memory at one time.  Note that as of
              this writing protoc does not optimize for this -- it will read the entire
              CodeGeneratorResponse before writing files to disk.
            *)

            insertion_point:string option;
            content:string option;
            (**
              The file contents.
            *)

            generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t option;
          }
          val make: ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          (** Helper function to generate a message using default values *)

          val to_proto: t -> Runtime'.Writer.t
          (** Serialize the message to binary format *)

          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from binary format *)

          val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
          (** Serialize to Json (compatible with Yojson.Basic.t) *)

          val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from Json (compatible with Yojson.Basic.t) *)

          val name: unit -> string
          (** Fully qualified protobuf name of this message *)

          (**/**)
          type make_t = ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          val merge: t -> t -> t
          val to_proto': Runtime'.Writer.t -> t -> unit
          val from_proto_exn: Runtime'.Reader.t -> t
          val from_json_exn: Runtime'.Json.t -> t
          (**/**)
        end
        type t = {
          error:string option;
          (**
            Error message.  If non-empty, code generation failed.  The plugin process
            should exit with status code zero even if it reports an error in this way.

            This should be used to indicate errors in .proto files which prevent the
            code generator from generating correct code.  Errors which indicate a
            problem in protoc itself -- such as the input CodeGeneratorRequest being
            unparseable -- should be reported by writing a message to stderr and
            exiting with a non-zero status code.
          *)

          supported_features:int option;
          file:File.t list;
        }
        val make: ?error:string -> ?supported_features:int -> ?file:File.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?error:string -> ?supported_features:int -> ?file:File.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end
    end
  end
end = struct
  module rec Protobuf : sig
    module rec Compiler : sig

      (** The version number of protocol compiler. *)
      module rec Version : sig
        type t = {
          major:int option;
          minor:int option;
          patch:int option;
          suffix:string option;
          (**
            A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
            be empty for mainline stable releases.
          *)

        }
        val make: ?major:int -> ?minor:int -> ?patch:int -> ?suffix:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?major:int -> ?minor:int -> ?patch:int -> ?suffix:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      (** An encoded CodeGeneratorRequest is written to the plugin's stdin. *)
      and CodeGeneratorRequest : sig
        type t = {
          file_to_generate:string list;
          parameter:string option;
          (**
            The generator parameter passed on the command-line.
          *)

          compiler_version:Version.t option;
          proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list;
        }
        val make: ?file_to_generate:string list -> ?parameter:string -> ?compiler_version:Version.t -> ?proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?file_to_generate:string list -> ?parameter:string -> ?compiler_version:Version.t -> ?proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      (** The plugin writes an encoded CodeGeneratorResponse to stdout. *)
      and CodeGeneratorResponse : sig

        (** Sync with code_generator.h. *)
        module rec Feature : sig
          type t =
            | FEATURE_NONE
            | FEATURE_PROTO3_OPTIONAL

          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end

        (** Represents a single generated file. *)
        and File : sig
          type t = {
            name:string option;
            (**
              The file name, relative to the output directory.  The name must not
              contain "." or ".." components and must be relative, not be absolute (so,
              the file cannot lie outside the output directory).  "/" must be used as
              the path separator, not "\\".

              If the name is omitted, the content will be appended to the previous
              file.  This allows the generator to break large files into small chunks,
              and allows the generated text to be streamed back to protoc so that large
              files need not reside completely in memory at one time.  Note that as of
              this writing protoc does not optimize for this -- it will read the entire
              CodeGeneratorResponse before writing files to disk.
            *)

            insertion_point:string option;
            content:string option;
            (**
              The file contents.
            *)

            generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t option;
          }
          val make: ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          (** Helper function to generate a message using default values *)

          val to_proto: t -> Runtime'.Writer.t
          (** Serialize the message to binary format *)

          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from binary format *)

          val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
          (** Serialize to Json (compatible with Yojson.Basic.t) *)

          val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from Json (compatible with Yojson.Basic.t) *)

          val name: unit -> string
          (** Fully qualified protobuf name of this message *)

          (**/**)
          type make_t = ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          val merge: t -> t -> t
          val to_proto': Runtime'.Writer.t -> t -> unit
          val from_proto_exn: Runtime'.Reader.t -> t
          val from_json_exn: Runtime'.Json.t -> t
          (**/**)
        end
        type t = {
          error:string option;
          (**
            Error message.  If non-empty, code generation failed.  The plugin process
            should exit with status code zero even if it reports an error in this way.

            This should be used to indicate errors in .proto files which prevent the
            code generator from generating correct code.  Errors which indicate a
            problem in protoc itself -- such as the input CodeGeneratorRequest being
            unparseable -- should be reported by writing a message to stderr and
            exiting with a non-zero status code.
          *)

          supported_features:int option;
          file:File.t list;
        }
        val make: ?error:string -> ?supported_features:int -> ?file:File.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?error:string -> ?supported_features:int -> ?file:File.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end
    end
  end = struct
    module rec Compiler : sig

      (** The version number of protocol compiler. *)
      module rec Version : sig
        type t = {
          major:int option;
          minor:int option;
          patch:int option;
          suffix:string option;
          (**
            A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
            be empty for mainline stable releases.
          *)

        }
        val make: ?major:int -> ?minor:int -> ?patch:int -> ?suffix:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?major:int -> ?minor:int -> ?patch:int -> ?suffix:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      (** An encoded CodeGeneratorRequest is written to the plugin's stdin. *)
      and CodeGeneratorRequest : sig
        type t = {
          file_to_generate:string list;
          parameter:string option;
          (**
            The generator parameter passed on the command-line.
          *)

          compiler_version:Version.t option;
          proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list;
        }
        val make: ?file_to_generate:string list -> ?parameter:string -> ?compiler_version:Version.t -> ?proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?file_to_generate:string list -> ?parameter:string -> ?compiler_version:Version.t -> ?proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      (** The plugin writes an encoded CodeGeneratorResponse to stdout. *)
      and CodeGeneratorResponse : sig

        (** Sync with code_generator.h. *)
        module rec Feature : sig
          type t =
            | FEATURE_NONE
            | FEATURE_PROTO3_OPTIONAL

          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end

        (** Represents a single generated file. *)
        and File : sig
          type t = {
            name:string option;
            (**
              The file name, relative to the output directory.  The name must not
              contain "." or ".." components and must be relative, not be absolute (so,
              the file cannot lie outside the output directory).  "/" must be used as
              the path separator, not "\\".

              If the name is omitted, the content will be appended to the previous
              file.  This allows the generator to break large files into small chunks,
              and allows the generated text to be streamed back to protoc so that large
              files need not reside completely in memory at one time.  Note that as of
              this writing protoc does not optimize for this -- it will read the entire
              CodeGeneratorResponse before writing files to disk.
            *)

            insertion_point:string option;
            content:string option;
            (**
              The file contents.
            *)

            generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t option;
          }
          val make: ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          (** Helper function to generate a message using default values *)

          val to_proto: t -> Runtime'.Writer.t
          (** Serialize the message to binary format *)

          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from binary format *)

          val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
          (** Serialize to Json (compatible with Yojson.Basic.t) *)

          val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from Json (compatible with Yojson.Basic.t) *)

          val name: unit -> string
          (** Fully qualified protobuf name of this message *)

          (**/**)
          type make_t = ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          val merge: t -> t -> t
          val to_proto': Runtime'.Writer.t -> t -> unit
          val from_proto_exn: Runtime'.Reader.t -> t
          val from_json_exn: Runtime'.Json.t -> t
          (**/**)
        end
        type t = {
          error:string option;
          (**
            Error message.  If non-empty, code generation failed.  The plugin process
            should exit with status code zero even if it reports an error in this way.

            This should be used to indicate errors in .proto files which prevent the
            code generator from generating correct code.  Errors which indicate a
            problem in protoc itself -- such as the input CodeGeneratorRequest being
            unparseable -- should be reported by writing a message to stderr and
            exiting with a non-zero status code.
          *)

          supported_features:int option;
          file:File.t list;
        }
        val make: ?error:string -> ?supported_features:int -> ?file:File.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?error:string -> ?supported_features:int -> ?file:File.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end
    end = struct
      module rec Version : sig
        type t = {
          major:int option;
          minor:int option;
          patch:int option;
          suffix:string option;
          (**
            A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
            be empty for mainline stable releases.
          *)

        }
        val make: ?major:int -> ?minor:int -> ?patch:int -> ?suffix:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?major:int -> ?minor:int -> ?patch:int -> ?suffix:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = Version
        let name () = ".google.protobuf.compiler.Version"
        type t = {
          major:int option;
          minor:int option;
          patch:int option;
          suffix:string option;
        }
        type make_t = ?major:int -> ?minor:int -> ?patch:int -> ?suffix:string -> unit -> t
        let make ?major ?minor ?patch ?suffix () = { major; minor; patch; suffix }
        let merge =
        let merge_major = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "major", "major"), int32_int) ) in
        let merge_minor = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "minor", "minor"), int32_int) ) in
        let merge_patch = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "patch", "patch"), int32_int) ) in
        let merge_suffix = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((4, "suffix", "suffix"), string) ) in
        fun t1 t2 -> {
        major = (merge_major t1.major t2.major);
        minor = (merge_minor t1.minor t2.minor);
        patch = (merge_patch t1.patch t2.patch);
        suffix = (merge_suffix t1.suffix t2.suffix);
         }
        let spec () = Runtime'.Spec.( basic_opt ((1, "major", "major"), int32_int) ^:: basic_opt ((2, "minor", "minor"), int32_int) ^:: basic_opt ((3, "patch", "patch"), int32_int) ^:: basic_opt ((4, "suffix", "suffix"), string) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer { major; minor; patch; suffix } -> serialize writer major minor patch suffix

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor major minor patch suffix = { major; minor; patch; suffix } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun { major; minor; patch; suffix } -> serialize major minor patch suffix
        let from_json_exn =
          let constructor major minor patch suffix = { major; minor; patch; suffix } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end
      and CodeGeneratorRequest : sig
        type t = {
          file_to_generate:string list;
          parameter:string option;
          (**
            The generator parameter passed on the command-line.
          *)

          compiler_version:Version.t option;
          proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list;
        }
        val make: ?file_to_generate:string list -> ?parameter:string -> ?compiler_version:Version.t -> ?proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?file_to_generate:string list -> ?parameter:string -> ?compiler_version:Version.t -> ?proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = CodeGeneratorRequest
        let name () = ".google.protobuf.compiler.CodeGeneratorRequest"
        type t = {
          file_to_generate:string list;
          parameter:string option;
          compiler_version:Version.t option;
          proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list;
        }
        type make_t = ?file_to_generate:string list -> ?parameter:string -> ?compiler_version:Version.t -> ?proto_file:Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto.t list -> unit -> t
        let make ?(file_to_generate = []) ?parameter ?compiler_version ?(proto_file = []) () = { file_to_generate; parameter; compiler_version; proto_file }
        let merge =
        let merge_file_to_generate = Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "file_to_generate", "fileToGenerate"), string, not_packed) ) in
        let merge_parameter = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "parameter", "parameter"), string) ) in
        let merge_compiler_version = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((3, "compiler_version", "compilerVersion"), (message (module Version))) ) in
        let merge_proto_file = Runtime'.Merge.merge Runtime'.Spec.( repeated ((15, "proto_file", "protoFile"), (message (module Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto)), not_packed) ) in
        fun t1 t2 -> {
        file_to_generate = (merge_file_to_generate t1.file_to_generate t2.file_to_generate);
        parameter = (merge_parameter t1.parameter t2.parameter);
        compiler_version = (merge_compiler_version t1.compiler_version t2.compiler_version);
        proto_file = (merge_proto_file t1.proto_file t2.proto_file);
         }
        let spec () = Runtime'.Spec.( repeated ((1, "file_to_generate", "fileToGenerate"), string, not_packed) ^:: basic_opt ((2, "parameter", "parameter"), string) ^:: basic_opt ((3, "compiler_version", "compilerVersion"), (message (module Version))) ^:: repeated ((15, "proto_file", "protoFile"), (message (module Imported'modules.Descriptor.Google.Protobuf.FileDescriptorProto)), not_packed) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer { file_to_generate; parameter; compiler_version; proto_file } -> serialize writer file_to_generate parameter compiler_version proto_file

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor file_to_generate parameter compiler_version proto_file = { file_to_generate; parameter; compiler_version; proto_file } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun { file_to_generate; parameter; compiler_version; proto_file } -> serialize file_to_generate parameter compiler_version proto_file
        let from_json_exn =
          let constructor file_to_generate parameter compiler_version proto_file = { file_to_generate; parameter; compiler_version; proto_file } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end
      and CodeGeneratorResponse : sig

        (** Sync with code_generator.h. *)
        module rec Feature : sig
          type t =
            | FEATURE_NONE
            | FEATURE_PROTO3_OPTIONAL

          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end

        (** Represents a single generated file. *)
        and File : sig
          type t = {
            name:string option;
            (**
              The file name, relative to the output directory.  The name must not
              contain "." or ".." components and must be relative, not be absolute (so,
              the file cannot lie outside the output directory).  "/" must be used as
              the path separator, not "\\".

              If the name is omitted, the content will be appended to the previous
              file.  This allows the generator to break large files into small chunks,
              and allows the generated text to be streamed back to protoc so that large
              files need not reside completely in memory at one time.  Note that as of
              this writing protoc does not optimize for this -- it will read the entire
              CodeGeneratorResponse before writing files to disk.
            *)

            insertion_point:string option;
            content:string option;
            (**
              The file contents.
            *)

            generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t option;
          }
          val make: ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          (** Helper function to generate a message using default values *)

          val to_proto: t -> Runtime'.Writer.t
          (** Serialize the message to binary format *)

          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from binary format *)

          val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
          (** Serialize to Json (compatible with Yojson.Basic.t) *)

          val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from Json (compatible with Yojson.Basic.t) *)

          val name: unit -> string
          (** Fully qualified protobuf name of this message *)

          (**/**)
          type make_t = ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          val merge: t -> t -> t
          val to_proto': Runtime'.Writer.t -> t -> unit
          val from_proto_exn: Runtime'.Reader.t -> t
          val from_json_exn: Runtime'.Json.t -> t
          (**/**)
        end
        type t = {
          error:string option;
          (**
            Error message.  If non-empty, code generation failed.  The plugin process
            should exit with status code zero even if it reports an error in this way.

            This should be used to indicate errors in .proto files which prevent the
            code generator from generating correct code.  Errors which indicate a
            problem in protoc itself -- such as the input CodeGeneratorRequest being
            unparseable -- should be reported by writing a message to stderr and
            exiting with a non-zero status code.
          *)

          supported_features:int option;
          file:File.t list;
        }
        val make: ?error:string -> ?supported_features:int -> ?file:File.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?error:string -> ?supported_features:int -> ?file:File.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = CodeGeneratorResponse
        module rec Feature : sig
          type t =
            | FEATURE_NONE
            | FEATURE_PROTO3_OPTIONAL

          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end = struct
          module This'_ = Feature
          type t =
            | FEATURE_NONE
            | FEATURE_PROTO3_OPTIONAL

          let name () = ".google.protobuf.compiler.CodeGeneratorResponse.Feature"
          let to_int = function
            | FEATURE_NONE -> 0
            | FEATURE_PROTO3_OPTIONAL -> 1
          let from_int_exn = function
            | 0 -> FEATURE_NONE
            | 1 -> FEATURE_PROTO3_OPTIONAL
            | n -> Runtime'.Result.raise (`Unknown_enum_value n)
          let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
          let to_string = function
            | FEATURE_NONE -> "FEATURE_NONE"
            | FEATURE_PROTO3_OPTIONAL -> "FEATURE_PROTO3_OPTIONAL"
          let from_string_exn = function
            | "FEATURE_NONE" -> FEATURE_NONE
            | "FEATURE_PROTO3_OPTIONAL" -> FEATURE_PROTO3_OPTIONAL
            | s -> Runtime'.Result.raise (`Unknown_enum_name s)

        end
        and File : sig
          type t = {
            name:string option;
            (**
              The file name, relative to the output directory.  The name must not
              contain "." or ".." components and must be relative, not be absolute (so,
              the file cannot lie outside the output directory).  "/" must be used as
              the path separator, not "\\".

              If the name is omitted, the content will be appended to the previous
              file.  This allows the generator to break large files into small chunks,
              and allows the generated text to be streamed back to protoc so that large
              files need not reside completely in memory at one time.  Note that as of
              this writing protoc does not optimize for this -- it will read the entire
              CodeGeneratorResponse before writing files to disk.
            *)

            insertion_point:string option;
            content:string option;
            (**
              The file contents.
            *)

            generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t option;
          }
          val make: ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          (** Helper function to generate a message using default values *)

          val to_proto: t -> Runtime'.Writer.t
          (** Serialize the message to binary format *)

          val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from binary format *)

          val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
          (** Serialize to Json (compatible with Yojson.Basic.t) *)

          val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
          (** Deserialize from Json (compatible with Yojson.Basic.t) *)

          val name: unit -> string
          (** Fully qualified protobuf name of this message *)

          (**/**)
          type make_t = ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          val merge: t -> t -> t
          val to_proto': Runtime'.Writer.t -> t -> unit
          val from_proto_exn: Runtime'.Reader.t -> t
          val from_json_exn: Runtime'.Json.t -> t
          (**/**)
        end = struct
          module This'_ = File
          let name () = ".google.protobuf.compiler.CodeGeneratorResponse.File"
          type t = {
            name:string option;
            insertion_point:string option;
            content:string option;
            generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t option;
          }
          type make_t = ?name:string -> ?insertion_point:string -> ?content:string -> ?generated_code_info:Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo.t -> unit -> t
          let make ?name ?insertion_point ?content ?generated_code_info () = { name; insertion_point; content; generated_code_info }
          let merge =
          let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ) in
          let merge_insertion_point = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "insertion_point", "insertionPoint"), string) ) in
          let merge_content = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((15, "content", "content"), string) ) in
          let merge_generated_code_info = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((16, "generated_code_info", "generatedCodeInfo"), (message (module Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo))) ) in
          fun t1 t2 -> {
          name = (merge_name t1.name t2.name);
          insertion_point = (merge_insertion_point t1.insertion_point t2.insertion_point);
          content = (merge_content t1.content t2.content);
          generated_code_info = (merge_generated_code_info t1.generated_code_info t2.generated_code_info);
           }
          let spec () = Runtime'.Spec.( basic_opt ((1, "name", "name"), string) ^:: basic_opt ((2, "insertion_point", "insertionPoint"), string) ^:: basic_opt ((15, "content", "content"), string) ^:: basic_opt ((16, "generated_code_info", "generatedCodeInfo"), (message (module Imported'modules.Descriptor.Google.Protobuf.GeneratedCodeInfo))) ^:: nil )
          let to_proto' =
            let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
            fun writer { name; insertion_point; content; generated_code_info } -> serialize writer name insertion_point content generated_code_info

          let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
          let from_proto_exn =
            let constructor name insertion_point content generated_code_info = { name; insertion_point; content; generated_code_info } in
            Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
          let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
          let to_json options =
            let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
            fun { name; insertion_point; content; generated_code_info } -> serialize name insertion_point content generated_code_info
          let from_json_exn =
            let constructor name insertion_point content generated_code_info = { name; insertion_point; content; generated_code_info } in
            Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
          let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
        end
        let name () = ".google.protobuf.compiler.CodeGeneratorResponse"
        type t = {
          error:string option;
          supported_features:int option;
          file:File.t list;
        }
        type make_t = ?error:string -> ?supported_features:int -> ?file:File.t list -> unit -> t
        let make ?error ?supported_features ?(file = []) () = { error; supported_features; file }
        let merge =
        let merge_error = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((1, "error", "error"), string) ) in
        let merge_supported_features = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "supported_features", "supportedFeatures"), uint64_int) ) in
        let merge_file = Runtime'.Merge.merge Runtime'.Spec.( repeated ((15, "file", "file"), (message (module File)), not_packed) ) in
        fun t1 t2 -> {
        error = (merge_error t1.error t2.error);
        supported_features = (merge_supported_features t1.supported_features t2.supported_features);
        file = (merge_file t1.file t2.file);
         }
        let spec () = Runtime'.Spec.( basic_opt ((1, "error", "error"), string) ^:: basic_opt ((2, "supported_features", "supportedFeatures"), uint64_int) ^:: repeated ((15, "file", "file"), (message (module File)), not_packed) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer { error; supported_features; file } -> serialize writer error supported_features file

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor error supported_features file = { error; supported_features; file } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun { error; supported_features; file } -> serialize error supported_features file
        let from_json_exn =
          let constructor error supported_features file = { error; supported_features; file } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end
    end
  end
end
