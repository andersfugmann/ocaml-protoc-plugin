<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>FieldOptions (ocaml-protoc-plugin.Google_types.Descriptor.Google.Protobuf.FieldOptions)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">ocaml-protoc-plugin</a> &#x00BB; <a href="../../../../index.html">Google_types</a> &#x00BB; <a href="../../../index.html">Descriptor</a> &#x00BB; <a href="../../index.html">Google</a> &#x00BB; <a href="../index.html">Protobuf</a> &#x00BB; FieldOptions</nav><header class="odoc-preamble"><h1>Module <code><span>Protobuf.FieldOptions</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-CType"><a href="#module-CType" class="anchor"></a><code><span><span class="keyword">module</span> <a href="CType/index.html">CType</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-JSType"><a href="#module-JSType" class="anchor"></a><code><span><span class="keyword">module</span> <a href="JSType/index.html">JSType</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span><span>{</span></code><ol><li id="type-t.ctype" class="def record field anchored"><a href="#type-t.ctype" class="anchor"></a><code><span>ctype : <a href="CType/index.html#type-t">CType.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The ctype option instructs the C++ code generator to use a different representation of the field than it normally would. See the specific options below. This option is not yet implemented in the open source release -- sorry, we'll try to include it in a future version!</p><span class="comment-delim">*)</span></div></li><li id="type-t.packed" class="def record field anchored"><a href="#type-t.packed" class="anchor"></a><code><span>packed : <span>bool option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The packed option can be enabled for repeated primitive fields to enable a more efficient representation on the wire. Rather than repeatedly writing the tag and type for each element, the entire array is encoded as a single length-delimited blob. In proto3, only explicit setting it to false will avoid using packed encoding.</p><span class="comment-delim">*)</span></div></li><li id="type-t.deprecated" class="def record field anchored"><a href="#type-t.deprecated" class="anchor"></a><code><span>deprecated : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Clients can define custom options in extensions of this message. See above.</p><span class="comment-delim">*)</span></div></li><li id="type-t.lazy'" class="def record field anchored"><a href="#type-t.lazy'" class="anchor"></a><code><span>lazy' : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Should this field be parsed lazily? Lazy applies only to message-type fields. It means that when the outer message is initially parsed, the inner message's contents will not be parsed but instead stored in encoded form. The inner message will actually be parsed when it is first accessed.</p><p>This is only a hint. Implementations are free to choose whether to use eager or lazy parsing regardless of the value of this option. However, setting this option true suggests that the protocol author believes that using lazy parsing on this field is worth the additional bookkeeping overhead typically needed to implement it.</p><p>This option does not affect the public interface of any generated code; all method signatures remain the same. Furthermore, thread-safety of the interface is not affected by this option; const methods remain safe to call from multiple threads concurrently, while non-const methods continue to require exclusive access.</p><p>Note that implementations may choose not to check required fields within a lazy sub-message. That is, calling IsInitialized() on the outer message may return true even if the inner message has missing required fields. This is necessary because otherwise the inner message would have to be parsed in order to perform the check, defeating the purpose of lazy parsing. An implementation which chooses not to check required fields must be consistent about it. That is, for any particular sub-message, the implementation must either *always* check its required fields, or *never* check its required fields, regardless of whether or not the message has been parsed.</p><p>As of 2021, lazy does no correctness checks on the byte stream during parsing. This may lead to crashes if and when an invalid byte stream is finally parsed upon access.</p><p>TODO(b/211906113): Enable validation on lazy fields.</p><span class="comment-delim">*)</span></div></li><li id="type-t.jstype" class="def record field anchored"><a href="#type-t.jstype" class="anchor"></a><code><span>jstype : <a href="JSType/index.html#type-t">JSType.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The jstype option determines the JavaScript type used for values of the field. The option is permitted only for 64 bit integral and fixed types (int64, uint64, sint64, fixed64, sfixed64). A field with jstype JS_STRING is represented as JavaScript string, which avoids loss of precision that can happen when a large value is converted to a floating point JavaScript. Specifying JS_NUMBER for the jstype causes the generated JavaScript code to use the JavaScript &quot;number&quot; type. The behavior of the default option JS_NORMAL is implementation dependent.</p><p>This option is an enum to permit additional types to be added, e.g. goog.math.Integer.</p><span class="comment-delim">*)</span></div></li><li id="type-t.weak" class="def record field anchored"><a href="#type-t.weak" class="anchor"></a><code><span>weak : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>For Google-internal migration only. Do not use.</p><span class="comment-delim">*)</span></div></li><li id="type-t.unverified_lazy" class="def record field anchored"><a href="#type-t.unverified_lazy" class="anchor"></a><code><span>unverified_lazy : bool;</span></code></li><li id="type-t.uninterpreted_option" class="def record field anchored"><a href="#type-t.uninterpreted_option" class="anchor"></a><code><span>uninterpreted_option : <span><a href="../UninterpretedOption/index.html#type-t">UninterpretedOption.t</a> list</span>;</span></code></li><li id="type-t.extensions'" class="def record field anchored"><a href="#type-t.extensions'" class="anchor"></a><code><span>extensions' : <a href="../../../../../Ocaml_protoc_plugin/Extensions/index.html#type-t">Ocaml_protoc_plugin.Extensions.t</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><span class="optlabel">?ctype</span>:<a href="CType/index.html#type-t">CType.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?packed</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?deprecated</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?lazy'</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?jstype</span>:<a href="JSType/index.html#type-t">JSType.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?weak</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?unverified_lazy</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?uninterpreted_option</span>:<span><a href="../UninterpretedOption/index.html#type-t">UninterpretedOption.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?extensions'</span>:<a href="../../../../../Ocaml_protoc_plugin/Extensions/index.html#type-t">Ocaml_protoc_plugin.Extensions.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Helper function to generate a message using default values</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_proto"><a href="#val-to_proto" class="anchor"></a><code><span><span class="keyword">val</span> to_proto : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../../Ocaml_protoc_plugin/Writer/index.html#type-t">Ocaml_protoc_plugin.Writer.t</a></span></code></div><div class="spec-doc"><p>Serialize the message to binary format</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_proto"><a href="#val-from_proto" class="anchor"></a><code><span><span class="keyword">val</span> from_proto : 
  <span><a href="../../../../../Ocaml_protoc_plugin/Reader/index.html#type-t">Ocaml_protoc_plugin.Reader.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, <span>[&gt; <a href="../../../../../Ocaml_protoc_plugin/Result/index.html#type-error">Ocaml_protoc_plugin.Result.error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Deserialize from binary format</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_json"><a href="#val-to_json" class="anchor"></a><code><span><span class="keyword">val</span> to_json : 
  <span><a href="../../../../../Ocaml_protoc_plugin/Json_options/index.html#type-t">Ocaml_protoc_plugin.Json_options.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../Ocaml_protoc_plugin/Json/index.html#type-t">Ocaml_protoc_plugin.Json.t</a></span></code></div><div class="spec-doc"><p>Serialize to Json (compatible with Yojson.Basic.t)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_json"><a href="#val-from_json" class="anchor"></a><code><span><span class="keyword">val</span> from_json : 
  <span><a href="../../../../../Ocaml_protoc_plugin/Json/index.html#type-t">Ocaml_protoc_plugin.Json.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, <span>[&gt; <a href="../../../../../Ocaml_protoc_plugin/Result/index.html#type-error">Ocaml_protoc_plugin.Result.error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Deserialize from Json (compatible with Yojson.Basic.t)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-name"><a href="#val-name" class="anchor"></a><code><span><span class="keyword">val</span> name : <span>unit <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Fully qualified protobuf name of this message</p></div></div></div></body></html>
